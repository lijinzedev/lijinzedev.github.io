<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SpringMVC 异步模式 | Curiosity的博客</title><meta name="keywords" content="SpringMVC - 异步模式"><meta name="author" content="Curiosity"><meta name="copyright" content="Curiosity"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 SpringMVC异步模式  Spring的异步请求模式是Spring3.2就推出了，它是基于Servlet3.0规范实现的，而此规范是2011年推出的。   1 SpringMVC的同步模式   此处需要明晰一个概念：比如tomcat，它既是一个web服务器，同时它也是个servlet后端容器（调ava后端服务），所以要区分清楚这两个概念。请求处理线程是有限的，宝贵的资源~（注意它和处理线">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMVC 异步模式">
<meta property="og:url" content="https://lijinzedev.github.io/2020/12/13/SpringMVC-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Curiosity的博客">
<meta property="og:description" content="1 SpringMVC异步模式  Spring的异步请求模式是Spring3.2就推出了，它是基于Servlet3.0规范实现的，而此规范是2011年推出的。   1 SpringMVC的同步模式   此处需要明晰一个概念：比如tomcat，它既是一个web服务器，同时它也是个servlet后端容器（调ava后端服务），所以要区分清楚这两个概念。请求处理线程是有限的，宝贵的资源~（注意它和处理线">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png">
<meta property="article:published_time" content="2020-12-13T17:01:22.000Z">
<meta property="article:modified_time" content="2021-09-18T07:50:32.099Z">
<meta property="article:author" content="Curiosity">
<meta property="article:tag" content="SpringMVC - 异步模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png"><link rel="shortcut icon" href="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png"><link rel="canonical" href="https://lijinzedev.github.io/2020/12/13/SpringMVC-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-18 07:50:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Curiosity的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringMVC 异步模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-13T17:01:22.000Z" title="发表于 2020-12-13 17:01:22">2020-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-18T07:50:32.099Z" title="更新于 2021-09-18 07:50:32">2021-09-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SpringMVC-%E5%9F%BA%E7%A1%80/">SpringMVC - 基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-springmvc异步模式"><a class="markdownIt-Anchor" href="#1-springmvc异步模式"></a> 1 SpringMVC异步模式</h1>
<blockquote>
<p>Spring的异步请求模式是Spring3.2就推出了，它是基于Servlet3.0规范实现的，而此规范是2011年推出的。</p>
</blockquote>
<h2 id="1-springmvc的同步模式"><a class="markdownIt-Anchor" href="#1-springmvc的同步模式"></a> 1 SpringMVC的同步模式</h2>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/SpringMVC-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/image-20201213174021230.png" alt="image-20201213174021230"></p>
<blockquote>
<p>此处需要明晰一个概念：比如tomcat，它既是一个web服务器，同时它也是个servlet后端容器（调ava后端服务），所以要区分清楚这两个概念。请求处理线程是有限的，宝贵的资源~（注意它和处理线程的区别）</p>
</blockquote>
<h2 id="2-callable案例"><a class="markdownIt-Anchor" href="#2-callable案例"></a> 2 <strong>Callable</strong>案例</h2>
<p>1 请求处理线程：处理线程属于Web服务器线程，负责处理用户请求，采用线程池管理</p>
<p>2 异步线程：异步线程属于用户自定义线程，可采用线程池管理</p>
<h4 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Callable&lt;Object&gt; <span class="title">testCallable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    Callable&lt;Object&gt; callable = <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 子线程开始&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 子线程结束&quot;</span>);</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;ken&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;35&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;local&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a class="markdownIt-Anchor" href="#结果"></a> 结果</h4>
<blockquote>
<p>前端等待5秒后拿到数据，注意：异步模式对前端来说，是无感知的，这是后端的一种技术。所以这个和我们自己开启一个线程处理，立马返回给前端是有非常大的不同的，需要注意~</p>
</blockquote>
<p>由此我们可以看出，主线程早早就结束了（需要注意，<strong>此时还并没有把response返回的，此处一定要注意</strong>），真正干事的是子线程（交给<code>TaskExecutor</code>去处理的，后续分析过程中可以看到），它的大致的一个处理流程图可以如下：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/SpringMVC-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/image-20201213174039201.png" alt="image-20201213174039201"></p>
<p>这里能够很直接的看出：我们很大程度上提高了我们<code>请求处理线程</code>的利用率，从而肯定就提高了我们系统的吞吐量。</p>
<h4 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h4>
<blockquote>
<p>当Controller返回值是Callable的时候，Spring就会将Callable交给TaskExecutor去处理（一个隔离的线程池），与此同时将DispatcherServlet里的拦截器、Filter等等都马上退出线程，但是response仍然保持打开的状态，Callable线程处理完成后，Spring MVC讲请求重新派发给容器**（注意这里的重新派发，和拦截器密切相关）**。根据Callabel返回结果，继续处理（比如参数绑定、视图解析等等就和之前一样了）</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-callable">Spring文档介绍</a></p>
<h2 id="3-webasynctask"><a class="markdownIt-Anchor" href="#3-webasynctask"></a> 3 <strong>WebAsyncTask</strong></h2>
<blockquote>
<p>Note that you can also set the default timeout value on a <code>DeferredResult</code>, a <code>ResponseBodyEmitter</code>, and an <code>SseEmitter</code>. For a <code>Callable</code>, you can use <code>WebAsyncTask</code> to provide a timeout value.</p>
<p>如果我们需要超时处理的回调或者错误处理的回调，我们可以使用<code>WebAsyncTask</code>代替Callable</p>
</blockquote>
<h3 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/webasync&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;Object&gt; <span class="title">testWebAsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    Callable&lt;Object&gt; callable = <span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 子线程开始&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 子线程结束&quot;</span>);</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;ken&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;35&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;local&quot;</span>, <span class="string">&quot;中国&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">    WebAsyncTask&lt;Object&gt; webAsyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">6000</span>, callable);</span><br><span class="line">    <span class="comment">// 注意：onCompletion表示完成，不管你是否超时、是否抛出异常，这个函数都会执行的</span></span><br><span class="line">    webAsyncTask.onCompletion(() -&gt; System.out.println(<span class="string">&quot;程序执行完成&quot;</span>));</span><br><span class="line">    <span class="comment">// 这两个返回的内容，最终都会放进response里面去===========</span></span><br><span class="line">    webAsyncTask.onTimeout(() -&gt; <span class="string">&quot;程序[超时]的回调&quot;</span>);</span><br><span class="line">    <span class="comment">// 备注：这个是Spring5新增的</span></span><br><span class="line">    webAsyncTask.onError(() -&gt; <span class="string">&quot;程序[出现异常]的回调&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> webAsyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.context.request.async;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.task.AsyncTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holder for a &#123;<span class="doctag">@link</span> Callable&#125;, a timeout value, and a task executor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the value type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAsyncTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 正常执行的函数（通过WebAsyncTask的构造函数可以传进来）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; callable;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 处理超时时间（ms），可通过构造函数指定，也可以不指定（不会有超时处理）</span></span><br><span class="line">    <span class="keyword">private</span> Long timeout;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 执行任务的执行器。可以构造函数设置进来，手动指定。</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTaskExecutor executor;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 若设置了，会根据此名称去IoC容器里找这个Bean （和上面二选一）  </span></span><br><span class="line">	<span class="comment">// 若传了executorName,请务必调用set方法设置beanFactory</span></span><br><span class="line">    <span class="keyword">private</span> String executorName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">	<span class="comment">// 超时的回调</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; timeoutCallback;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 发生错误的回调</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; errorCallback;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 完成的回调（不管超时还是错误都会执行）</span></span><br><span class="line">    <span class="keyword">private</span> Runnable completionCallback;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a &#123;<span class="doctag">@code</span> WebAsyncTask&#125; wrapping the given &#123;<span class="doctag">@link</span> Callable&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> callable the callable for concurrent handling</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebAsyncTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(callable, <span class="string">&quot;Callable must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a &#123;<span class="doctag">@code</span> WebAsyncTask&#125; with a timeout value and a &#123;<span class="doctag">@link</span> Callable&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timeout a timeout value in milliseconds</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> callable the callable for concurrent handling</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebAsyncTask</span><span class="params">(<span class="keyword">long</span> timeout, Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callable);</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a &#123;<span class="doctag">@code</span> WebAsyncTask&#125; with a timeout value, an executor name, and a &#123;<span class="doctag">@link</span> Callable&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timeout the timeout value in milliseconds; ignored if &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> executorName the name of an executor bean to use</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> callable the callable for concurrent handling</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebAsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Long timeout, String executorName, Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callable);</span><br><span class="line">        Assert.notNull(executorName, <span class="string">&quot;Executor name must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.executorName = executorName;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a &#123;<span class="doctag">@code</span> WebAsyncTask&#125; with a timeout value, an executor instance, and a Callable.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> timeout the timeout value in milliseconds; ignored if &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> executor the executor to use</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> callable the callable for concurrent handling</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebAsyncTask</span><span class="params">(<span class="meta">@Nullable</span> Long timeout, AsyncTaskExecutor executor, Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(callable);</span><br><span class="line">        Assert.notNull(executor, <span class="string">&quot;Executor must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the &#123;<span class="doctag">@link</span> Callable&#125; to use for concurrent handling (never &#123;<span class="doctag">@code</span> null&#125;).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> Callable&lt;?&gt; getCallable() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.callable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the timeout value in milliseconds, or &#123;<span class="doctag">@code</span> null&#125; if no timeout is set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * A &#123;<span class="doctag">@link</span> BeanFactory&#125; to use for resolving an executor name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This factory reference will automatically be set when</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> WebAsyncTask&#125; is used within a Spring MVC controller.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the AsyncTaskExecutor to use for concurrent handling,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if none specified.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncTaskExecutor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.executor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.executorName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">&quot;BeanFactory is required to look up an executor bean by name&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBean(<span class="keyword">this</span>.executorName, AsyncTaskExecutor.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register code to invoke when the async request times out.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method is called from a container thread when an async request times</span></span><br><span class="line"><span class="comment">	 * out before the &#123;<span class="doctag">@code</span> Callable&#125; has completed. The callback is executed in</span></span><br><span class="line"><span class="comment">	 * the same thread and therefore should return without blocking. It may return</span></span><br><span class="line"><span class="comment">	 * an alternative value to use, including an &#123;<span class="doctag">@link</span> Exception&#125; or return</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> CallableProcessingInterceptor#RESULT_NONE RESULT_NONE&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(Callable&lt;V&gt; callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeoutCallback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register code to invoke for an error during async request processing.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method is called from a container thread when an error occurred</span></span><br><span class="line"><span class="comment">	 * while processing an async request before the &#123;<span class="doctag">@code</span> Callable&#125; has</span></span><br><span class="line"><span class="comment">	 * completed. The callback is executed in the same thread and therefore</span></span><br><span class="line"><span class="comment">	 * should return without blocking. It may return an alternative value to</span></span><br><span class="line"><span class="comment">	 * use, including an &#123;<span class="doctag">@link</span> Exception&#125; or return</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> CallableProcessingInterceptor#RESULT_NONE RESULT_NONE&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Callable&lt;V&gt; callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCallback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Register code to invoke when the async request completes.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method is called from a container thread when an async request</span></span><br><span class="line"><span class="comment">	 * completed for any reason, including timeout and network error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.completionCallback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CallableProcessingInterceptor <span class="title">getInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallableProcessingInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function">Object <span class="title">handleTimeout</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (timeoutCallback != <span class="keyword">null</span> ? timeoutCallback.call() : CallableProcessingInterceptor.RESULT_NONE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function">Object <span class="title">handleError</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task, Throwable t)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (errorCallback != <span class="keyword">null</span> ? errorCallback.call() : CallableProcessingInterceptor.RESULT_NONE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (completionCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    completionCallback.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>WebAsyncTask 的异步编程 API。相比于 @Async 注解，WebAsyncTask 提供更加健全的 超时处理 和 异常处理 支持。但是@Async也有更优秀的地方，就是他不仅仅能用于controller中~~~~（任意地方）</p>
</blockquote>
<h2 id="4-deferredresult"><a class="markdownIt-Anchor" href="#4-deferredresult"></a> <strong>4 DeferredResult</strong></h2>
<blockquote>
<p><code>DeferredResult</code>使用方式与Callable类似，但在返回结果上不一样，<strong>它返回的时候实际结果可能没有生成</strong>，实际的结果可能会在<strong>另外的线程</strong>里面设置到<code>DeferredResult</code>中去。</p>
</blockquote>
<h3 id="官方demo"><a class="markdownIt-Anchor" href="#官方demo"></a> 官方Demo</h3>
<blockquote>
<p>The controller can produce the return value asynchronously, from a different thread — for example, in response to an external event (JMS message), a scheduled task, or other event.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/quotes&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">quotes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Save the deferredResult somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// From some other thread...</span></span><br><span class="line">deferredResult.setResult(result);</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<blockquote>
<p>我们第一个请求<code>/hello</code>，会先<code>deferredResult</code>存起来，然后前端页面是一直等待（转圈状态）的。知道我发第二个请求：<code>setHelloToAll</code>，所有的相关页面才会有响应~~</p>
</blockquote>
<ol>
<li>controller 返回一个<code>DeferredResult</code>，我们把它保存到内存里或者List里面（供后续访问）</li>
<li>Spring MVC调用<code>request.startAsync()</code>，开启异步处理</li>
<li>与此同时将<code>DispatcherServlet</code>里的拦截器、Filter等等都马上退出主线程，<strong>但是response仍然保持打开的状态</strong></li>
<li>应用通过另外一个线程（可能是MQ消息、定时任务等）给<code>DeferredResult</code> set值。然后<code>Spring MVC</code>会把这个请求再次派发给servlet容器</li>
<li><code>DispatcherServlet</code>再次被调用，然后处理后续的标准流程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/deferred&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">helloGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先存起来，等待触发</span></span><br><span class="line">    deferredResultList.add(deferredResult);</span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/deferred&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 让所有hold住的请求给与响应</span></span><br><span class="line">    deferredResultList.forEach(d -&gt; d.setResult(<span class="string">&quot;say hello to all&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="源码-2"><a class="markdownIt-Anchor" href="#源码-2"></a> 源码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object RESULT_NONE = <span class="keyword">new</span> Object()</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 超时时间（ms） 可以不配置</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Long timeout;</span><br><span class="line">	<span class="comment">// 相当于超时的话的，传给回调函数的值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object timeoutResult;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这三种回调也都是支持的</span></span><br><span class="line">	<span class="keyword">private</span> Runnable timeoutCallback;</span><br><span class="line">	<span class="keyword">private</span> Consumer&lt;Throwable&gt; errorCallback;</span><br><span class="line">	<span class="keyword">private</span> Runnable completionCallback;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个比较强大，就是能把我们结果再交给这个自定义的函数处理了 他是个@FunctionalInterface</span></span><br><span class="line">	<span class="keyword">private</span> DeferredResultHandler resultHandler;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Object result = RESULT_NONE;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> expired = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断这个DeferredResult是否已经被set过了（被set过的对象，就可以移除了嘛）</span></span><br><span class="line">	<span class="comment">// 如果expired表示已经过期了你还没set，也是返回false的</span></span><br><span class="line">	<span class="comment">// Spring4.0之后提供的</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isSetOrExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.result != RESULT_NONE || <span class="keyword">this</span>.expired);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 没有isSetOrExpired 强大，建议使用上面那个</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.result != RESULT_NONE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还可以获得set进去的结果</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Object resultToCheck = <span class="keyword">this</span>.result;</span><br><span class="line">		<span class="keyword">return</span> (resultToCheck != RESULT_NONE ? resultToCheck : <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.timeoutCallback = callback;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Consumer&lt;Throwable&gt; callback)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.errorCallback = callback;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.completionCallback = callback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果你的result还需要处理，可以这是一个resultHandler，会对你设置进去的结果进行处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setResultHandler</span><span class="params">(DeferredResultHandler resultHandler)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(resultHandler, <span class="string">&quot;DeferredResultHandler is required&quot;</span>);</span><br><span class="line">		<span class="comment">// Immediate expiration check outside of the result lock</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.expired) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Object resultToHandle;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="comment">// Got the lock in the meantime: double-check expiration status</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.expired) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			resultToHandle = <span class="keyword">this</span>.result;</span><br><span class="line">			<span class="keyword">if</span> (resultToHandle == RESULT_NONE) &#123;</span><br><span class="line">				<span class="comment">// No result yet: store handler for processing once it comes in</span></span><br><span class="line">				<span class="keyword">this</span>.resultHandler = resultHandler;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			resultHandler.handleResult(resultToHandle);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Failed to handle existing result&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 我们发现，这里调用是private方法setResultInternal，我们设置进来的结果result，会经过它的处理</span></span><br><span class="line">	<span class="comment">// 而它的处理逻辑也很简单，如果我们提供了resultHandler，它会把这个值进一步的交给我们的resultHandler处理</span></span><br><span class="line">	<span class="comment">// 若我们没有提供此resultHandler，那就保存下这个result即可</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setResult</span><span class="params">(T result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> setResultInternal(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setResultInternal</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Immediate expiration check outside of the result lock</span></span><br><span class="line">		<span class="keyword">if</span> (isSetOrExpired()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DeferredResultHandler resultHandlerToUse;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="comment">// Got the lock in the meantime: double-check expiration status</span></span><br><span class="line">			<span class="keyword">if</span> (isSetOrExpired()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// At this point, we got a new result to process</span></span><br><span class="line">			<span class="keyword">this</span>.result = result;</span><br><span class="line">			resultHandlerToUse = <span class="keyword">this</span>.resultHandler;</span><br><span class="line">			<span class="keyword">if</span> (resultHandlerToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.resultHandler = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		resultHandlerToUse.handleResult(result);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发生错误了，也可以设置一个值。这个result会被记下来，当作result</span></span><br><span class="line">	<span class="comment">// 注意这个和setResult的唯一区别，这里入参是Object类型，而setResult只能set规定的指定类型</span></span><br><span class="line">	<span class="comment">// 定义成Obj是有原因的：因为我们一般会把Exception等异常对象放进来。。。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setErrorResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> setResultInternal(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拦截器 注意最终finally里面，都可能会调用我们的自己的处理器resultHandler(若存在的话)</span></span><br><span class="line">	<span class="comment">// afterCompletion不会调用resultHandler~~~~~~~~~~~~~</span></span><br><span class="line">	<span class="function"><span class="keyword">final</span> DeferredResultProcessingInterceptor <span class="title">getInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DeferredResultProcessingInterceptor() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> &lt;S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">handleTimeout</span><span class="params">(NativeWebRequest request, DeferredResult&lt;S&gt; deferredResult)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">boolean</span> continueProcessing = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (timeoutCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">						timeoutCallback.run();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (timeoutResult != RESULT_NONE) &#123;</span><br><span class="line">						continueProcessing = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							setResultInternal(timeoutResult);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">							logger.debug(<span class="string">&quot;Failed to handle timeout result&quot;</span>, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> continueProcessing;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> &lt;S&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">handleError</span><span class="params">(NativeWebRequest request, DeferredResult&lt;S&gt; deferredResult, Throwable t)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (errorCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">						errorCallback.accept(t);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						setResultInternal(t);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;Failed to handle error result&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> &lt;S&gt; <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(NativeWebRequest request, DeferredResult&lt;S&gt; deferredResult)</span> </span>&#123;</span><br><span class="line">				expired = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (completionCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">					completionCallback.run();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内部函数式接口 DeferredResultHandler</span></span><br><span class="line">	<span class="meta">@FunctionalInterface</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeferredResultHandler</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(Object result)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>DeferredResult</code>的超时处理，采用委托机制，也就是在实例<code>DeferredResult</code>时给予一个超时时长（毫秒），同时在<code>onTimeout</code>中委托（传入）一个新的处理线程（<strong>我们可以认为是超时线程</strong>）；当超时时间到来，<code>DeferredResult</code>启动超时线程，超时线程处理业务，封装返回数据，给<code>DeferredResult</code>赋值（正确返回的或错误返回的）</p>
</blockquote>
<h3 id="高级使用"><a class="markdownIt-Anchor" href="#高级使用"></a> 高级使用</h3>
<h4 id="1-长轮询服务端推送消息long-polling"><a class="markdownIt-Anchor" href="#1-长轮询服务端推送消息long-polling"></a> 1 长轮询服务端推送消息（long polling）</h4>
<p>在<code>WebSocket</code>协议之前(它是2011年发布的)，有三种实现双向通信的方式：<strong>轮询（polling）</strong>、<strong>长轮询（long-polling）**和**iframe流（streaming）</strong>。</p>
<ul>
<li><strong>轮询（polling）</strong>：这个不解释了。优点是实现简单粗暴，后台处理简单。缺点也是大大的，耗流量、耗CPU</li>
<li><strong>长轮询（long-polling）</strong>：长轮询是对轮询的改进版。客户端发送HTTP给服务器之后，看有没有新消息，如果没有新消息，就一直等待（而不是一直去请求了）。当有新消息的时候，才会返回给客户端。 优点是对轮询做了优化，时效性也较好。<strong>缺点是：保持连接会消耗资源; 服务器没有返回有效数据，程序超时</strong></li>
<li><strong>iframe流（streaming）</strong>：是在页面中插入一个<code>隐藏的iframe</code>，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。</li>
<li><strong>WebSocket</strong>：WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。它将TCP的Socket（套接字）应用在了webpage上。 它的有点一大把：支持双向通信，实时性更强；可发送二进制文件；非常节省流量。 但也是有缺点的：<code>浏览器支持程度不一致</code>，不支持断开重连 .目前主流</li>
</ul>
<p><code>apollo配置中心</code>的实现原理，apollo的发布配置推送变更消息就是用<code>DeferredResult</code>实现的。它的大概实现步骤如下：</p>
<ol>
<li>apollo客户端会像服务端发送<code>长轮询http请求</code>，超时时间60秒</li>
<li>当超时后返回客户端一个304 httpstatus,表明配置没有变更，客户端<code>继续这个步骤重复发起请求</code></li>
<li>当有发布配置的时候，服务端会调用<code>DeferredResult.setResult</code>返回200状态码。客户端收到响应结果后，<strong>会发起请求获取变更后的配置信息</strong>（注意这里是另外一个请求）</li>
</ol>
<h4 id="2-demo"><a class="markdownIt-Anchor" href="#2-demo"></a> 2 Demo</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 超时时间设置为60s</span></span><br><span class="line">        configurer.setDefaultTimeout(TimeUnit.SECONDS.toMillis(<span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>服务端简单代码模拟如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值为List，因为监视同一个名称空间的长轮询可能有N个（毕竟可能有多个客户端用同一份配置嘛）</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;DeferredResult&lt;String&gt;&gt;&gt; watchRequests = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/all/watchrequests&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getWatchRequests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> watchRequests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟长轮询：apollo客户端来监听配置文件的变更~  可以指定namespace 监视指定的NameSpace</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/watch/&#123;namespace&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">watch</span><span class="params">(<span class="meta">@PathVariable(&quot;namespace&quot;)</span> String namespace)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Request received,namespace is&quot;</span> + namespace + <span class="string">&quot;,当前时间：&quot;</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当deferredResult完成时（不论是超时还是异常还是正常完成），都应该移除watchRequests中相应的watch key</span></span><br><span class="line">        deferredResult.onCompletion(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;onCompletion，移除对namespace：&quot;</span> + namespace + <span class="string">&quot;的监视~&quot;</span>);</span><br><span class="line">            List&lt;DeferredResult&lt;String&gt;&gt; list = watchRequests.get(namespace);</span><br><span class="line">            list.remove(deferredResult);</span><br><span class="line">            <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">                watchRequests.remove(namespace);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;DeferredResult&lt;String&gt;&gt; list = watchRequests.computeIfAbsent(namespace, (k) -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        list.add(deferredResult);</span><br><span class="line">        <span class="keyword">return</span> deferredResult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟发布namespace配置：修改配置</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/publish/&#123;namespace&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishConfig</span><span class="params">(<span class="meta">@PathVariable(&quot;namespace&quot;)</span> String namespace)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do Something for update config</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (watchRequests.containsKey(namespace)) &#123;</span><br><span class="line">            List&lt;DeferredResult&lt;String&gt;&gt; deferredResults = watchRequests.get(namespace);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知所有watch这个namespace变更的长轮训配置变更结果</span></span><br><span class="line">            <span class="keyword">for</span> (DeferredResult&lt;String&gt; deferredResult : deferredResults) &#123;</span><br><span class="line">                deferredResult.setResult(namespace + <span class="string">&quot; changed，时间为&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>apollo处理超时时候会抛出一个异常<code>AsyncRequestTimeoutException</code>，因此我们全局处理一下就成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalControllerExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_MODIFIED)</span><span class="comment">//返回304状态码  效果同HttpServletResponse#sendError(int) 但这样更优雅</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(AsyncRequestTimeoutException.class)</span> <span class="comment">//捕获特定异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAsyncRequestTimeoutException</span><span class="params">(AsyncRequestTimeoutException e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handleAsyncRequestTimeoutException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用<code>Ajax</code>模拟Client端的伪代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长轮询：一直去监听指定namespace的配置文件</span></span><br><span class="line"><span class="function">function <span class="title">watchConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:<span class="string">&quot;http://localhost:8080/demo_war/watch/classroomconfig&quot;</span>,</span><br><span class="line">        method:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">        success:function(response,status)&#123;</span><br><span class="line">            <span class="keyword">if</span>(status == <span class="number">304</span>)&#123;</span><br><span class="line">                watchConfig(); <span class="comment">//超时，没有更改，那就继续去监听</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(status == <span class="number">200</span>)&#123;</span><br><span class="line">                getNewConfig(); <span class="comment">//监听到更改后，立马去获取最新的配置文件内容回来做事</span></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                    watchConfig(); <span class="comment">// 昨晚事后又去监听着</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用去监听获取配置文件的函数</span></span><br><span class="line">watchConfig();</span><br></pre></td></tr></table></figure>
<h2 id="5-responsebodyemitter与sseemitter"><a class="markdownIt-Anchor" href="#5-responsebodyemitter与sseemitter"></a> 5 ResponseBodyEmitter与SseEmitter</h2>
<blockquote>
<p><code>Callback</code>和<code>DeferredResult</code>用于设置单个结果，如果有多个结果需要set返回给客户端时，可以使用<code>SseEmitter以及ResponseBodyEmitter</code>，each object is written with a compatible <code>HttpMessageConverter</code>。返回值可以直接写他们本身，也可以放在<code>ResponseEntity</code>里面</p>
<p>它俩都是Spring4.2之后提供的类。由<code>ResponseBodyEmitterReturnValueHandler</code>负责处理。 这个和Spring5提供的webFlux技术已经很像<br>
Emitter：发射器</p>
</blockquote>
<p>它们的使用方式几乎同：<code>DeferredResult</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/events&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseBodyEmitter <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResponseBodyEmitter emitter = <span class="keyword">new</span> ResponseBodyEmitter();</span><br><span class="line">    <span class="comment">// Save the emitter somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In some other thread</span></span><br><span class="line">emitter.send(<span class="string">&quot;Hello once&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// and again later on</span></span><br><span class="line">emitter.send(<span class="string">&quot;Hello again&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// and done at some point</span></span><br><span class="line">emitter.complete();</span><br></pre></td></tr></table></figure>
<p><code>SseEmitter</code>是<code>ResponseBodyEmitter</code>的子类,它提供<code>Server-Sent Events（Sse）</code>.服务器事件发送是”HTTP Streaming”的另一个变种技术.只是从服务器发送的事件按照<code>W3C Server-Sent Events</code>规范来的（推荐使用） 它的使用方式上，完全同上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(path=&quot;/events&quot;, produces=MediaType.TEXT_EVENT_STREAM_VALUE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SseEmitter <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SseEmitter emitter = <span class="keyword">new</span> SseEmitter();</span><br><span class="line">    <span class="comment">// Save the emitter somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In some other thread</span></span><br><span class="line">emitter.send(<span class="string">&quot;Hello once&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// and again later on</span></span><br><span class="line">emitter.send(<span class="string">&quot;Hello again&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// and done at some point</span></span><br><span class="line">emitter.complete();</span><br></pre></td></tr></table></figure>
<p><code>Server-Sent Events</code>这个规范能够来用于它们的预期使用目的：就是从server发送events到clients（服务器推）.在Spring MVC中可以很容易的实现.仅仅需要返回一个<code>SseEmitter</code>类型的值.</p>
<blockquote>
<p>向这种场景在在线游戏、在线协作、金融领域等等都有很好的应用。当然，如果你对稳定性什么的要求都非常高，官方也推荐最好是使用<code>WebSocket</code>来实现~</p>
</blockquote>
<p><code>ResponseBodyEmitter</code>允许通过<code>HttpMessageConverter</code>把发送的events写到对象到response中.这可能是最常见的情况。<strong>例如写JSON</strong></p>
<h2 id="6-streamingresponsebody"><a class="markdownIt-Anchor" href="#6-streamingresponsebody"></a> 6 StreamingResponseBody</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;StreamingResponseBody&gt; <span class="title">downLoad</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    MediaType mediaType = MediaTypeFactory</span><br><span class="line">        .getMediaType(fileName)</span><br><span class="line">        .orElse(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.setContentType(mediaType);</span><br><span class="line">    ContentDisposition disposition = ContentDisposition.builder(<span class="string">&quot;attachment&quot;</span>)</span><br><span class="line">        .filename(<span class="keyword">new</span> String(fileName.getBytes(<span class="string">&quot;UTF-8&quot;</span>), <span class="string">&quot;ISO-8859-1&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">    headers.setContentDisposition(disposition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;StreamingResponseBody&gt;(outputStream -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedOutputStream stream = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line">             BufferedInputStream inputStream = <span class="keyword">new</span> BufferedInputStream(ftpUtils.downFile(fileName));) &#123;</span><br><span class="line">            StreamUtils.copy(inputStream, stream);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.ftpUtils.ftpClient.completePendingCommand();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;, headers, HttpStatus.OK);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-异步优化"><a class="markdownIt-Anchor" href="#8-异步优化"></a> 8 异步优化</h2>
<p>Spring内部默认不使用线程池处理的（通过源码分析后面我们是能看到的）,为了提高处理的效率，我们可以自己优化，建议自己在配置里注入一个线程池供给使用，参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 提供一个mvc里专用的线程池。。。  这是全局的方式~~~~</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">mvcTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">25</span>);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最优解决方案不是像上面一样配置通用的，而是配置一个单独的专用的，如下~~~~</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置异步支持~~~~</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 设置一个用于异步执行的执行器~~~AsyncTaskExecutor</span></span><br><span class="line">        configurer.setTaskExecutor(mvcTaskExecutor());</span><br><span class="line">        configurer.setDefaultTimeout(<span class="number">60000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2-filter与handlerinterceptor"><a class="markdownIt-Anchor" href="#2-filter与handlerinterceptor"></a> 2 Filter与HandlerInterceptor</h1>
<h3 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> Filter</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，这里必须开启异步支持asyncSupported = true，否则报错：Async support must be enabled on a servlet and for all filters involved in async request processing</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initFilterBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + request.getRequestURI());</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="handlerinterceptor"><a class="markdownIt-Anchor" href="#handlerinterceptor"></a> <strong>HandlerInterceptor</strong></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---preHandle--&gt;&quot;</span> + request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---postHandle--&gt;&quot;</span> + request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---postHandle--&gt;&quot;</span> + request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册拦截器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// /**拦截所有请求</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> HelloInterceptor()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从上面可以看出，如果我们就是普通的Spring MVC的拦截器，preHandler会执行两次，这也符合我们上面分析的处理步骤。<strong>所以我们在书写preHandler的时候，一定要特别的注意，要让preHandler即使执行多次，也不要受到影响（幂等）</strong></p>
</blockquote>
<h3 id="异步拦截器"><a class="markdownIt-Anchor" href="#异步拦截器"></a> 异步拦截器</h3>
<blockquote>
<p>Spring MVC给提供了异步拦截器，能让我们更深入的参与进去异步request的生命周期里面去。其中最为常用的为：</p>
</blockquote>
<h4 id="asynchandlerinterceptor"><a class="markdownIt-Anchor" href="#asynchandlerinterceptor"></a> <code>AsyncHandlerInterceptor</code></h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncHelloInterceptor</span> <span class="keyword">implements</span> <span class="title">AsyncHandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是Spring3.2提供的方法，专门拦截异步请求的方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConcurrentHandlingStarted</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---afterConcurrentHandlingStarted--&gt;&quot;</span> + request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---preHandle--&gt;&quot;</span> + request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---postHandle--&gt;&quot;</span> + request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---afterCompletion--&gt;&quot;</span> + request.getRequestURI());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>AsyncHandlerInterceptor</code>提供了一个<code>afterConcurrentHandlingStarted()</code>方法, 这个方法会在<code>Controller</code>方法异步执行时开始执行, 而<code>Interceptor的postHandle</code>方法则是需要等到<code>Controller</code>的异步执行完才能执行</p>
<p><strong>（比如我们用<code>DeferredResult</code>的话，<code>afterConcurrentHandlingStarted</code>是在return的之后执行，而<code>postHandle()</code>是执行<code>.setResult()</code>之后执行）</strong></p>
<p>需要说明的是：如果我们不是异步请求，<code>afterConcurrentHandlingStarted</code>是不会执行的。所以我们可以把它当做加强版的<code>HandlerInterceptor</code>来用。平时我们若要使用拦截器，建议使用它。（Spring5，JDK8以后，很多的<code>xxxAdapter</code>都没啥用了，直接implements接口就成~）</p>
</blockquote>
<p>同样可以注册<code>CallableProcessingInterceptor</code>或者一个<code>DeferredResultProcessingInterceptor</code>用于更深度的集成异步request的生命周期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureAsyncSupport</span><span class="params">(AsyncSupportConfigurer configurer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册异步的拦截器、默认的超时时间、任务处理器TaskExecutor等等</span></span><br><span class="line">    <span class="comment">//configurer.registerCallableInterceptors();</span></span><br><span class="line">    <span class="comment">//configurer.registerDeferredResultInterceptors();</span></span><br><span class="line">    <span class="comment">//configurer.setDefaultTimeout();</span></span><br><span class="line">    <span class="comment">//configurer.setTaskExecutor();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="3-async注解"><a class="markdownIt-Anchor" href="#3-async注解"></a> 3  @Async注解</h1>
<blockquote>
<p>在开发过程中，我们会遇到很多使用线程池的业务场景，例如异步短信通知、异步记录操作日志。大多数使用线程池的场景，就是会将一些可以进行异步操作的业务放在线程池中去完成。</p>
<p>例如在生成订单的时候给用户发送短信，生成订单的结果不应该被发送短信的成功与否所左右，也就是说生成订单这个主操作是不依赖于发送短信这个操作，所以我们就可以把发送短信这个操作置为异步操作。</p>
</blockquote>
<p>Spring中用<code>@Async</code>注解标记的方法，称为异步方法，它会在调用方的当前线程之外的独立的线程中执行，其实就相当于我们自己<code>new Thread(()-&gt; System.out.println(&quot;hello world !&quot;))</code>这样在另一个线程中去执行相应的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Async 若把注解放在类上或者接口上，那么他所有的方法都会异步执行了~~~~（包括私有方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// 注意此处加上了此注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后只需要在配置里，开启对异步的支持即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 开启异步注解的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="async注解使用细节"><a class="markdownIt-Anchor" href="#async注解使用细节"></a> @Async注解使用细节</h4>
<ol>
<li><code>@Async</code>注解一般用在方法上，如果用在类上，那么这个类<strong>所有的方法</strong>都是异步执行的；</li>
<li><code>@Async</code>可以放在任何方法上，哪怕你是<code>private</code>的（<strong>若是同类调用</strong>，请务必注意注解失效的情况~~~）</li>
<li>所使用的<code>@Async</code>注解方法的类对象应该是Spring容器管理的bean对象</li>
<li><code>@Async</code>可以放在接口处（或者接口方法上）。但是只有使用的是JDK的动态代理时才有效，CGLIB会失效。因此建议：<code>统一写在实现类的方法上</code></li>
<li>需要注解<code>@EnableAsync</code>来开启异步注解的支持</li>
<li>若你希望得到<code>异步调用的返回值</code>，请你的返回值用<code>Futrue</code>变量包装起来</li>
<li></li>
</ol>
<h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1>
<blockquote>
<p><code>DeferredResult</code>需要<strong>自己用线程</strong>来处理结果<code>setResult</code>，而<code>Callable</code>的话不需要我们来维护一个结果处理线程。<br>
总体来说，<code>Callable</code>的话更为简单，同样的也是因为简单，灵活性不够；<br>
相对地，<code>DeferredResult</code>更为复杂一些，<strong>但是又极大的灵活性</strong>，所以能实现非常多个性化的、复杂的功能，可以设计高级应用。</p>
</blockquote>
<p><strong>有些较常见的场景， <code>Callable</code>也并不能解决，比如说：我们访问A接口，A接口调用三方的服务，服务<code>回调（注意此处指的回调，不是返回值）</code>B接口，这种情况就没办法使用Callable了，这个时候可以使用<code>DeferredResult</code></strong></p>
<p>使用原则：基本上在可以用<code>Callable</code>的时候，直接用<code>Callable</code>；而遇到<code>Callable</code>没法解决的场景的时候，可以尝试使用<code>DeferredResult</code>。</p>
<blockquote>
<p>在Reactive编程模型越来越流行的今天，多一点对异步编程模型（Spring MVC异步模式）的了解，可以更容易去接触Spring5带来的新特性—响应式编程。<br>
同时，异步编程是我们高效利用系统资源，提高系统吞吐量，编写高性能应用的必备技能。</p>
</blockquote>
<h1 id="5-参阅"><a class="markdownIt-Anchor" href="#5-参阅"></a> 5 参阅</h1>
<p>[]: <a target="_blank" rel="noopener" href="https://fangshixiang.blog.csdn.net/article/details/89430276">https://fangshixiang.blog.csdn.net/article/details/89430276</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Curiosity</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lijinzedev.github.io/2020/12/13/SpringMVC-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/">https://lijinzedev.github.io/2020/12/13/SpringMVC-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lijinzedev.github.io" target="_blank">Curiosity的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringMVC-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F/">SpringMVC - 异步模式</a></div><div class="post_share"><div class="social-share" data-image="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/15/WebFlux/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WebFlux</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/13/shell-Jar-%E7%AE%80%E5%8D%95%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">shell Jar 简单启动脚本</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Curiosity</div><div class="author-info__description">SpringBoot | Mybatis | Java | Mysql</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lijinzedev"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lijinzedev" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2533755010@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">万般皆下品,唯有读书高</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-springmvc%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text"> 1 SpringMVC异步模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-springmvc%E7%9A%84%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> 1 SpringMVC的同步模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-callable%E6%A1%88%E4%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text"> 2 Callable案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.0.1.</span> <span class="toc-text"> 代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-number">1.2.0.2.</span> <span class="toc-text"> 结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.2.0.3.</span> <span class="toc-text"> 结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-webasynctask"><span class="toc-number">1.3.</span> <span class="toc-text"> 3 WebAsyncTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-deferredresult"><span class="toc-number">1.4.</span> <span class="toc-text"> 4 DeferredResult</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9demo"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 官方Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81-2"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text"> 高级使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AFlong-polling"><span class="toc-number">1.4.4.1.</span> <span class="toc-text"> 1 长轮询服务端推送消息（long polling）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-demo"><span class="toc-number">1.4.4.2.</span> <span class="toc-text"> 2 Demo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-responsebodyemitter%E4%B8%8Esseemitter"><span class="toc-number">1.5.</span> <span class="toc-text"> 5 ResponseBodyEmitter与SseEmitter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-streamingresponsebody"><span class="toc-number">1.6.</span> <span class="toc-text"> 6 StreamingResponseBody</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BC%82%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text"> 8 异步优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-filter%E4%B8%8Ehandlerinterceptor"><span class="toc-number">2.</span> <span class="toc-text"> 2 Filter与HandlerInterceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-number">2.0.1.</span> <span class="toc-text"> Filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handlerinterceptor"><span class="toc-number">2.0.2.</span> <span class="toc-text"> HandlerInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">2.0.3.</span> <span class="toc-text"> 异步拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#asynchandlerinterceptor"><span class="toc-number">2.0.3.1.</span> <span class="toc-text"> AsyncHandlerInterceptor</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-async%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text"> 3  @Async注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#async%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.0.0.1.</span> <span class="toc-text"> @Async注解使用细节</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text"> 4 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%8F%82%E9%98%85"><span class="toc-number">5.</span> <span class="toc-text"> 5 参阅</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/16/mac-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="mac 常用命令">mac 常用命令</a><time datetime="2021-09-16T10:26:20.000Z" title="发表于 2021-09-16 10:26:20">2021-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/15/%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86/" title="单点登陆">单点登陆</a><time datetime="2021-09-15T17:56:56.000Z" title="发表于 2021-09-15 17:56:56">2021-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/14/mac-%E5%AE%89%E8%A3%85brew/" title="mac 安装brew">mac 安装brew</a><time datetime="2021-09-14T15:16:12.000Z" title="发表于 2021-09-14 15:16:12">2021-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/14/mac-man%E6%B1%89%E5%8C%96/" title="mac man汉化">mac man汉化</a><time datetime="2021-09-14T14:19:43.000Z" title="发表于 2021-09-14 14:19:43">2021-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/09/02/%E5%9C%A8YAML%E4%B8%AD%E4%BD%BF%E7%94%A8Maven%E5%8F%98%E9%87%8F/" title="在YAML中使用Maven变量">在YAML中使用Maven变量</a><time datetime="2021-09-02T16:06:42.000Z" title="发表于 2021-09-02 16:06:42">2021-09-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Curiosity</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>