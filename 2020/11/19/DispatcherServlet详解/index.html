<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>DispatcherServlet详解 | Curiosity的博客</title><meta name="keywords" content="源码"><meta name="author" content="Curiosity"><meta name="copyright" content="Curiosity"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  DispatcherServlet 过程分析  一 原始Servlet到SpringMvc  在过滤器执行完成之后，将会进入Servlet组件的执行中。首先出现的Servlet的类为HttpServlet，该类为抽象类   首先进入HttpServlet的service方法  12345678910111213141516171819&#x2F;*** 从Filter转向Servlet的入口方">
<meta property="og:type" content="article">
<meta property="og:title" content="DispatcherServlet详解">
<meta property="og:url" content="https://lijinzedev.github.io/2020/11/19/DispatcherServlet%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Curiosity的博客">
<meta property="og:description" content="[toc]  DispatcherServlet 过程分析  一 原始Servlet到SpringMvc  在过滤器执行完成之后，将会进入Servlet组件的执行中。首先出现的Servlet的类为HttpServlet，该类为抽象类   首先进入HttpServlet的service方法  12345678910111213141516171819&#x2F;*** 从Filter转向Servlet的入口方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png">
<meta property="article:published_time" content="2020-11-19T18:33:56.000Z">
<meta property="article:modified_time" content="2024-07-19T06:03:08.405Z">
<meta property="article:author" content="Curiosity">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png"><link rel="shortcut icon" href="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png"><link rel="canonical" href="https://lijinzedev.github.io/2020/11/19/DispatcherServlet%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-19 06:03:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.4.2"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">155</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">112</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Curiosity的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">DispatcherServlet详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-19T18:33:56.000Z" title="发表于 2020-11-19 18:33:56">2020-11-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-19T06:03:08.405Z" title="更新于 2024-07-19 06:03:08">2024-07-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%BA%90%E7%A0%81/">源码</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%BA%90%E7%A0%81/SpringMvc%E6%BA%90%E7%A0%81/">SpringMvc源码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[toc]</p>
<h1 id="dispatcherservlet-过程分析"><a class="markdownIt-Anchor" href="#dispatcherservlet-过程分析"></a> DispatcherServlet 过程分析</h1>
<h2 id="一-原始servlet到springmvc"><a class="markdownIt-Anchor" href="#一-原始servlet到springmvc"></a> 一 原始Servlet到SpringMvc</h2>
<blockquote>
<p>在过滤器执行完成之后，将会进入Servlet组件的执行中。首先出现的Servlet的类为HttpServlet，该类为抽象类</p>
</blockquote>
<ol>
<li>首先进入HttpServlet的service方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从Filter转向Servlet的入口方法，方法负责把原始的Servlet请求与相应转化为基于HTTP的Servlet请求与相应，* 再调用重载的Serivce方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对两个参数进行转换,只有基于Servlet的Web容器,产生的HTTP请求与响应就是下面返回的对应类型,这里的转换是用来提供重载Service方法</span></span><br><span class="line">        request = (HttpServletRequest) req;</span><br><span class="line">        response = (HttpServletResponse) res;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(lStrings.getString(<span class="string">&quot;http.non_http&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用重载的方法</span></span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入父类的service进行执行逻辑</li>
</ol>
<blockquote>
<p>其中GET方法请求处理有些特殊，进行了HTTP缓存规范判断，如判断请求头中的If—Modified—Since已达到直接从浏览器缓存中获取请求结果的目的。但前提是需要支持LastModified功能。在DIspatcherServlet中，GET请求缓存通过另外的途径来实现，这里的getLastModified方法固定返回-1，故固定执行doGet方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"><span class="comment">// 对请求的方法进行  判断,支持以下七种方法</span></span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            <span class="comment">// 如果不支持缓存策略,执行doGet方法逻辑</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> ifModifiedSince;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                <span class="comment">// Invalid date header - proceed as if none was set</span></span><br><span class="line">                ifModifiedSince = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">// 进入此逻辑表示请求方法不被支持,会直接返回错误响应</span></span><br><span class="line">        <span class="comment">// 因为PATCH方法与其他无法识别的请求方法在FrameworkServlet中重写的该方法提供了支持,故此处SpringMvc 下将不会进入</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>
<p>在HttpServlet的do*方法中，均返回固定的错误请求，错误状态码为405，请求方法不被支持。所以若要对对应的请求方法提供支持，子类必须重写父类对应的请求do*系列方法。</p>
<p>在SpringMvc中，真是的Servlet实例为DispatcherServlet，其中其父类FrameworkServlet重写了HttpServlet中所有的do*方法。</p>
<p>因为在SpringMvc的设计中，可以根据@RequestMapping注解标记的方法条件，把请求根据请求方法分发到不同的处理器方法上，故最终所有的方法需要调用同一个分发逻辑，所以在FrameworkServlet中的do*方法，可以看到都调用了同一个方法processRequest</p>
<p>其实在不同的do*系列方法中，根据HTTP请求方法的定义，会做一些默认的处理，如doHead方法会调用doGet方法，FrameworkServlet中并没有重写doHead，而是通过重写doGet实现doHead的内部功能。同时还有doOptions方法进行了Options类型请求方法的特有处理，doTrace方法包括了特有的Trace相关的跟踪操作。</p>
<p>在上述过程执行完成之后，SpringMvc 提供的Servlet组件与Web容器整合，在后续的过程中，将调用与Servlet无关的processRequest方法，并以此为入口，进入到SpringMvc框架对请求的处理中。上述过程是从原始的Web容器调用到MVC框架组建的过程。</p>
</li>
</ol>
</blockquote>
<h2 id="二-dispatcherservlet请求入口"><a class="markdownIt-Anchor" href="#二-dispatcherservlet请求入口"></a> 二 DispatcherServlet请求入口</h2>
<blockquote>
<p>在原始的Web容器入口开始，一步步对请求进行处理，在执行到Servlet层之后，开始进入SpringMvc的请求处理组件。所有的请求处理入口都在Spring的DispatchServlet组件中，都是以processDispatch开头的。</p>
</blockquote>
<h3 id="1-处理请求方法"><a class="markdownIt-Anchor" href="#1-处理请求方法"></a> 1 处理请求方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process this request, publishing an event regardless of the outcome.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The actual event handling is performed by the abstract</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #doService&#125; template method.</span></span><br><span class="line"><span class="comment"> * 处理请求方法，用于执行所有请求的处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">	<span class="comment">// 记录当前时间，用于日志记录</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="comment">// 失败原因，如请求处理过程抛出异常，则用该变量进行记录</span></span><br><span class="line">	<span class="type">Throwable</span> <span class="variable">failureCause</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 获取当前的本地上下文，存储为上一个本地化上下文变量，以便在此请求处理中使用新的本地化上下文，在使用完成后通过该变量恢复原始的本地化上下文</span></span><br><span class="line">	<span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line">	<span class="comment">// 构建当前请求的本地化上下文</span></span><br><span class="line">       <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line">	<span class="comment">// 同本地化上下文，这里先存储上一次请求的请求属性上下文，以便在此请求处理中使用新的请求属性上下文，在使用完成后根据该变量恢复原始的请求属性上下文</span></span><br><span class="line">	<span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">	<span class="comment">// 构造当前请求属性上下文</span></span><br><span class="line">       <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line">	<span class="comment">// 获取或创建当前请求的异步管理器，用于对异步相应结果提供支持</span></span><br><span class="line">	<span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">       <span class="comment">// 拦截器RequestBindingInterceptor的作用同上面构造上下文逻辑和下面初始化上下文持有器initContextHolders与重置上下文持有器restContextHolders的作用相同</span></span><br><span class="line">       <span class="comment">// 因为请求的处理与当前线程是异步的关系，所以在其他线程执行初始化操作时就需要使用执行注册的这个拦截器</span></span><br><span class="line">	asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br><span class="line">	<span class="comment">// 初始化上下文持有器，包括请求上下文处理器LocaleContextHolder和本地化上下文持有器RequestContextHolder，修改这两个持有器所持有得上下文为新建上下文</span></span><br><span class="line">	initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 初始化完成之后执行真正处理请求方法</span></span><br><span class="line">		doService(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">           <span class="comment">// 拦截Servlet和Io异常记录后再度抛出</span></span><br><span class="line">		failureCause = ex;</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">           <span class="comment">// 记录其他异常</span></span><br><span class="line">		failureCause = ex;</span><br><span class="line">           <span class="comment">// 记录后抛出新的前台异常</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 重置上下文持有器，重置为该方法前面的逻辑保存的原始上下文。在异步请求拦截器里面，重置上下文则把上下文设置为NULL，这里则设置之前的上下文</span></span><br><span class="line">		resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">		<span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 标记请求完成，并执行一些请求完成的回调方法</span></span><br><span class="line">			requestAttributes.requestCompleted();</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">// 日志</span></span><br><span class="line">		logResult(request, response, failureCause, asyncManager);</span><br><span class="line">           <span class="comment">// 向当前应用上下文中发布请求被处理的时间，事件类为ServletRequestHandlerEvent其中包含一些请求的相关属性，如请求路径、请求方法等</span></span><br><span class="line">		publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-请求分发概述"><a class="markdownIt-Anchor" href="#2-请求分发概述"></a> 2  请求分发概述</h3>
<blockquote>
<p>在整个方法中，每一段逻辑都有其自身的目的，且整体从前到后都是按照请求处理的流程在执行。同时，每一段逻辑的处理都涉及一些Spring Mvc 的组件</p>
</blockquote>
<ol>
<li>预处理多块请求</li>
<li>获取请求处理器</li>
<li>查询处理适配器</li>
<li>处理HTTP缓存</li>
<li>执行前置拦截器链</li>
<li>处理适配器执行</li>
<li>返回值视图名处理</li>
<li>执行后置拦截器链</li>
<li>处理返回值与响应</li>
<li>执行完成拦截器链</li>
<li>清理资源</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行请求分发到处理器</span></span><br><span class="line"><span class="comment">* 处理器通过当前应用中初始化的HandlerMapping处理器映射列表按顺序获取处理器</span></span><br><span class="line"><span class="comment">* 通过当前应用中初始化的HandlerAdapter处理适配器列表，获取支持当前请求处理器的处理适配器</span></span><br><span class="line"><span class="comment">* 该方法可以处理所有的请求方法。对于一些特殊的请求方法如Option是等，响应需要做额外的一些适配操作，该适配器操作交给请求处理器与处理适配器的逻辑去处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 定义一个已处理器请求，指向参数中的request，已处理请求后序可能改变</span></span><br><span class="line">   <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="comment">// 定义处理器执行链，内部封装拦截器列表与处理器</span></span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="comment">// 是否是多块请求，默认为否</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 获取与当前请求想关联的异步管理器，用于执行异步操作</span></span><br><span class="line">   <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">	<span class="comment">// 整体放在try中，用于捕获处理过程中的所有异常</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 用于保存处理器适配器执行后的返回结果</span></span><br><span class="line">      <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="comment">// 用于保存处理过程中发生的异常</span></span><br><span class="line">      <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">// 嵌套一个try，内部获取真实的处理异常，在异常处理中还有可能发生异常，上层的try作用为拦截这层try异常处理中发生的异常</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 检查多块请求，如果是多块请求，则返回一个新的请求，processRequest保存这个心得请求引用；否则返回原始请求</span></span><br><span class="line">         processedRequest = checkMultipart(request);</span><br><span class="line">         <span class="comment">// 判断两者是否是同一个引用，如果是说明是多块请求，且已经处理。此变量为true</span></span><br><span class="line">          multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">          <span class="comment">// 获取可处理当前请求的请求处理器，通过HandlerMapping查找，请求处理器中封装了拦截器链和对应的处理器，可以是具体的处理器方法</span></span><br><span class="line">         mappedHandler = getHandler(processedRequest);</span><br><span class="line">         <span class="comment">// 如果没有则执行没有处理器逻辑</span></span><br><span class="line">          <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 内部逻辑判断配置throwExceptionIfNoHandlerFound是否为true，如果为true则爆出异常，否则直接设置响应内容为404</span></span><br><span class="line">              <span class="comment">// 可以通过spring.mvc.throwExceptionIfNoHandlerFound设置其值，默认为false</span></span><br><span class="line">            noHandlerFound(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">          <span class="comment">// 根据当前请求的处理器获取支持该处理器的处理器适配器</span></span><br><span class="line">         <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">          <span class="comment">// 单独处理last-modified请求头，用于判断请求内容是否修改，如果未修改直接返回，浏览器使用本地缓存</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">          <span class="comment">// 只有get请求和head请求执行此判断</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">         <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">             <span class="comment">// 具体实现还是通过处理器适配器来实现的</span></span><br><span class="line">             <span class="comment">// 通过处理器适配器的getLastModified方法，传入请求与处理器，获取该请求对应内容的最后修改时间</span></span><br><span class="line">             <span class="comment">// 一般针对静态资源，返回静态资源的上一次修改时间，动态资源固定返回-1，表示不存在时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">            <span class="comment">// 经过判断，如果最后修改时间在当前请求中浏览器缓存时间之前，则直接返回状态码304，表示未修改，浏览器可以直接使用本地缓存作为请求内容</span></span><br><span class="line">             <span class="comment">// 否则继续执行请求处理逻辑，lastMOdified为-1固定执行后序请求处理逻辑</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">	<span class="comment">// 通过mappedHandler这个HandlerExecutionChain执行链的封装，链式执行其中所有拦截器的前置拦方法preHandler</span></span><br><span class="line">         <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">             <span class="comment">// 任意一个拦截器的前置方法返回了false，即提前结束请求的处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">          <span class="comment">// 最终执行处理器适配器的处理方法，传入请求，响应与其对应的处理器，对请求进行处理。在这个处理中，最终调用到了请求对应的处理器方法</span></span><br><span class="line">          <span class="comment">// 执行的返回值是ModelAndView类型，封装了模型数据与视图，后序对此结果进行处理并根据其中的视图与模型返回响应内容</span></span><br><span class="line">         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">		<span class="comment">// 如果异步处理开始，则直接返回，后序处理均通过异步执行</span></span><br><span class="line">         <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">		<span class="comment">// 应用默认视图名，如果返回值得ModelAndVIew中不包含视图名，则根据请求设置默认视图名</span></span><br><span class="line">         applyDefaultViewName(processedRequest, mv);</span><br><span class="line">          <span class="comment">// 请求处理正常完成，链式执行所有拦截器的postHandler方法。链式顺序与preHandler相反</span></span><br><span class="line">         mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          <span class="comment">// 发现异常保存异常</span></span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">         <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">         <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">          <span class="comment">// 在Spring Mvc4.3 版本以后，添加了支持error类型异常的处理。Throwable的子类除了Exception就是Error</span></span><br><span class="line">          <span class="comment">// 可以通过@ExceptionHandler处理这种类型的异常</span></span><br><span class="line">          <span class="comment">// 封装为嵌套异常，以供异常处理逻辑使用</span></span><br><span class="line">         dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 对上面的逻辑的执行结果进行处理，包括处理适配器的执行结果以及发生的异常处理等逻辑</span></span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">       <span class="comment">// 外层try的catch，用于拦截对执行结果的处理过程processDispatchResult中发生的异常</span></span><br><span class="line">       <span class="comment">// 拦截后链执行拦截器链afterCompletion方法。在该方法内部判断mappedHandler是否为空，如果不为空，则执行triggerAfterCompletion方法</span></span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">       <span class="comment">// 拦截Error类型的异常拦截后链式执行拦截器链的afterCompletion方法</span></span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 资源处理</span></span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">		 <span class="comment">//如果在异步请求执行中，则链式执行拦截器链中的afterConcurrentHandlingStarted方法，即针对异步请求的特殊处理</span></span><br><span class="line">         <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">         <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          </span><br><span class="line">         <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">         <span class="comment">// 如果是多块资源，则清理多块资源占用的系统资源，包括文件缓存等</span></span><br><span class="line">          <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-预处理多块请求"><a class="markdownIt-Anchor" href="#1-预处理多块请求"></a> 1  预处理多块请求</h4>
<blockquote>
<p>在SpringMvc中，对于多块请求有特殊的处理，如@RequestPart绑定多块请求参数与多块请求文件等。要想实现这些特殊处理，就需要先对请求类型为多块请求执行预处理，在请求分发前就执行该操作，并替换后序使用的请求已预处理过的多块请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果请求是多块请求，则转化为多块请求的多装数据类型，并标记多块请求解析器为可用</span></span><br><span class="line"><span class="comment"> * Convert the request into a multipart request, and make multipart resolver available.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no multipart resolver is set, simply use the existing request.</span></span><br><span class="line"><span class="comment"> * 如果设置为多块请求解析器，则直接使用原始请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the processed request (multipart wrapper if necessary) 如果是多块请求则返回请求的包装类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> MultipartResolver#resolveMultipart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> HttpServletRequest <span class="title function_">checkMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException &#123;</span><br><span class="line">    <span class="comment">// 如果多块请求解析器不为空，使用多块请求解析器判断是否是多块请求，如果是，则执行后面的逻辑</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.multipartResolver != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.multipartResolver.isMultipart(request)) &#123;</span><br><span class="line">       <span class="comment">// 如果当前请求已经是多块请求的包装类型，则打印日志，并且返回</span></span><br><span class="line">      <span class="keyword">if</span> (WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (request.getDispatcherType().equals(DispatcherType.REQUEST)) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Request already resolved to MultipartHttpServletRequest, e.g. by MultipartFilter&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 如果当前请求中包含异常（通过请求属性java.servlet.error.exception 有无判断） 则返回传入的参数请求</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (hasMultipartException(request)) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Multipart resolution previously failed for current request - &quot;</span> +</span><br><span class="line">               <span class="string">&quot;skipping re-resolution for undisturbed error rendering&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 否则执行多块请求解析</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 尝试通过多块请求解析器解析多块请求，并返回多块请求解析器包装过的多块请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.multipartResolver.resolveMultipart(request);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (MultipartException ex) &#123;</span><br><span class="line">             <span class="comment">// 发生异常时，先判断是否存在异常，如果已经存在则打印日志，否则抛出改异常</span></span><br><span class="line">            <span class="keyword">if</span> (request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">               logger.debug(<span class="string">&quot;Multipart resolution failed for error dispatch&quot;</span>, ex);</span><br><span class="line">               <span class="comment">// Keep processing error dispatch with regular request handle below</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// If not returned before: return original request.</span></span><br><span class="line">    <span class="comment">// 如果多块请求解析器为空，或者不为多块请求，或者执行其他不解析多块请求的多级，则直接返回原请求</span></span><br><span class="line">   <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<blockquote>
<p>默认情况下，多块请求解析器为StandardServletMultipartResolver 其判断请求是否为多块请求的依据是请求方法为POST，且请求的Content-Type以multipart开头</p>
<p>多块请求解析器除了提供判断是否是多块请求的方法 isMultipart与解析多块请求的方法resolveMultipart外，还提供了清理多块请求占用资源的方法cleanMultpart，在逻辑清理的时候会使用到该功能</p>
</blockquote>
<h4 id="2-查找请求处理器"><a class="markdownIt-Anchor" href="#2-查找请求处理器"></a> 2 查找请求处理器</h4>
<blockquote>
<p>对于请求的处理，最终都是要通过处理器来执行，SpringMvc把请求处理器的查找与请求处理器的执行分离。在doDispatch方法中，执行请求处理器的查找，也是SpringMvc的核心操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回该请求对应的请求处理链</span></span><br><span class="line"><span class="comment"> * Return the HandlerExecutionChain for this request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Tries all handler mappings in order.</span></span><br><span class="line"><span class="comment"> * 按顺序查找全部处理器映射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the HandlerExecutionChain, or &#123;<span class="doctag">@code</span> null&#125; if no handler could be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 	<span class="comment">// 如果请求映射列表不为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历全部处理器映射</span></span><br><span class="line">      <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">          <span class="comment">// 尝试执行当前处理器映射的获取处理器方法，获取与本次请求适配的处理器执行链</span></span><br><span class="line">         <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">          <span class="comment">// 不为空直接返回，即便有多个处理器执行链匹配，也只返回第一个，处理器映射排在前面的优先返回</span></span><br><span class="line">         <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<blockquote>
<p>​			@RequestMapping注解注册的处理器方法，其相关的处理器映射类为RequestMappingHandlerMapping，该映射器内部根据当前请求与所有的注解信息进行匹配，找到最佳匹配并封装为处理器执行链进行返回</p>
<p>​			这也正是SpringMvc高度封装的体现，把一个复杂的逻辑都封装为一个接口，不仅可以通过不同的接口实现来完成不同的映射查找功能，同时无论映射查找功能有多复杂，这里看到的代码结构仍然非常的清晰。在这里把抽象与封装的概念体现的淋漓尽致</p>
<p>​			同时注意，查找到的是处理器执行链，其中封装了最终执行的处理器，以及在执行处理器前后要执行的拦截器链，即把与改签请求匹配的所有的拦截器链式封装带处理器执行链中，以供后序使用</p>
</blockquote>
<h4 id="3-获取处理器适配器"><a class="markdownIt-Anchor" href="#3-获取处理器适配器"></a> 3 获取处理器适配器</h4>
<blockquote>
<p>根据请求的类型不同，又需要使用不同的适配器去执行处理器，要想使用对应的处理器适配器执行处理器，需要获取对应的适配器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回支持传入的处理器对象的处理器适配器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 遍历处理适配器列表，调用supports方法，找到支持该处理器的适配器</span></span><br><span class="line">      <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">		<span class="comment">// 按照顺序查找第一个支持的适配器被返回</span></span><br><span class="line">         <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> adapter;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;No adapter for handler [&quot;</span> + handler +</span><br><span class="line">         <span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<blockquote>
<p>​		处理器适配器不但是执行处理器，而且还有更大的作用即适配，用于把请求参数适配为处理器需要的参数，并执行处理器，之后再把处理器的返回值适配成ModelAndVIew统一的模型视图类型，用于后序操作做统一的处理。</p>
<p>​		对于@RequestMapping注解注册的处理器，类型为HandlerMethod，通过RequestMappingHandlerMapping返回。对弈该类型的处理器，其适配器为RequestMappingHandlerAdapter，内部处理逻辑极其复杂包括参数绑定和返回值处理。</p>
</blockquote>
<h4 id="4-处理http缓存"><a class="markdownIt-Anchor" href="#4-处理http缓存"></a> 4 处理HTTP缓存</h4>
<blockquote>
<p>​		在获取处理适配器之后，额外添加了用于支持HTTP缓存的功能，因为该功能是上层统一功能，故直接在通用处理逻辑中天健</p>
<p>​		HTTP缓存是HTTP协议标准中的定义，用于提高HTTP请求的效率。允许浏览器对GET请求获取的资源进行缓存，如css，js等，图片资源，在下次浏览器发起相同的请求时，会携带本地缓存的资源时间或其他与资源相关的信息作为请求头来传递，如果通过If-Modified-Since请求头携带本地缓存的资源的最近一次修改时间。而在服务器的处理逻辑中，则根据该资源的最后修改时间与请求信息中的一些标志信息做对比判断，如果判断结果是请求方缓存仍然有效，则直接返回状态码304，表示服务端为此资源进行修改，可以直接使用缓存中的资源。通过这种缓存方式大大较少了请求内耗，对于客户端来说体验更加友好，对于服务端来说，压力会更小。</p>
<p>​		这一段逻辑是为了实现缓存目的而出现。首先缓存只支持GET和HEAD请求，再通过处理适配器的getLastModified方法获取当前请求与请求处理器对应的资源的最后一次修改的时间，一般对于静态资源有最后一次修改时间。之后调用new ServletWebRequest(request,response).checkNotModified(lastModified)检查当前请求中携带的缓存信息是否过期，如果未过期，则直接返回304，不在执行后序处理，如果已过期，直接按照原逻辑执行后序处理</p>
<p>​		对处理器方法来说，以这种方式获取的是动态资源，动态资源不进行缓存，所以lastModified的值为-1</p>
</blockquote>
<h4 id="5-执行前置拦截器链"><a class="markdownIt-Anchor" href="#5-执行前置拦截器链"></a> 5 执行前置拦截器链</h4>
<blockquote>
<p>​		在查找请求处理器时，返回了请求处理器执行链，在其中封装了拦截器链，用于在执行请求逻辑前进行拦截、执行请求逻辑之后添加后置处理，还可以拦截所有请求处理，在所有处理完成时或发生异常时添加完成后操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行已注册拦截器的处理前拦截方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; 返回是否需要继续执行后序的处理，如果为false则表示请求被拦截器拦截，不再执行后序处理，否则继续执行后序处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">   <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">         <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">          <span class="comment">// 如果返回false则直接停止执行，视为处理完成，出发拦截器完成后方法</span></span><br><span class="line">         <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">            triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">          <span class="comment">//如果为true 拦截器索引为当前遍历的索引，用于提供给triggerAfterCompletion 使用</span></span><br><span class="line">         <span class="built_in">this</span>.interceptorIndex = i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<blockquote>
<p>​		在调用triggerAfterCompletion的时候，只会调用已经执行了preHandle方法的处理器（除了当前preHandle返回false的）。这就是索引interceptorIndex的作用</p>
</blockquote>
<h4 id="6-处理器适配器执行"><a class="markdownIt-Anchor" href="#6-处理器适配器执行"></a> 6 处理器适配器执行</h4>
<blockquote>
<p>​		在完成上面的所有处理之后，会进入处理适配的执行逻辑，这里只是简单调用才处理器的handler方法，返回ModleAndView的值。</p>
<p>​		这个方法是整个请求处理最核心的方法，也是在调用了这个方法之后，最终才调用了处理器方法。所有对请求处理逻辑的封装都是在这个方法内部</p>
</blockquote>
<h4 id="7-返回视图名处理"><a class="markdownIt-Anchor" href="#7-返回视图名处理"></a> 7 返回视图名处理</h4>
<blockquote>
<p>​		在处理适配器执行完成之后，返回了ModelAndView类型的返回值，在很多的情况下，返回值不包含视图，但对于响应结果来说，没有视图就无法产生响应，故此处会将执行默认的视图查找逻辑，以对此返回值应用默认视图。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Do we need view name translation?</span></span><br><span class="line"><span class="comment"> * 应用视图默认名称	 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">applyDefaultViewName</span><span class="params">(HttpServletRequest request, <span class="meta">@Nullable</span> ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 如果返回值不为空，并且不包含视图</span></span><br><span class="line">   <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.hasView()) &#123;</span><br><span class="line">       <span class="comment">// 根据逻辑获取默认的视图名称</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">defaultViewName</span> <span class="operator">=</span> getDefaultViewName(request);</span><br><span class="line">       <span class="comment">// 如果获取的默认视图名称不为null，则将设置为ModelAndView的视图名</span></span><br><span class="line">      <span class="keyword">if</span> (defaultViewName != <span class="literal">null</span>) &#123;</span><br><span class="line">         mv.setViewName(defaultViewName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过视图名翻译器来根据请求获取视图名称</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getDefaultViewName</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">this</span>.viewNameTranslator != <span class="literal">null</span> ? <span class="built_in">this</span>.viewNameTranslator.getViewName(request) : <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<blockquote>
<p>​		在视图名的获取逻辑中又出现了新的组件ViewNameTranslator,其类型为RequestToViewNameTranslator该组件的作用是根据请求获取一个视图名称,此处该组件其默认实现为DefaultReqeustToViewNameTranlator</p>
<p>​		在该实现中，获取视图名的逻辑为获取请求路径，并拼接此实现中的前缀和后缀，作为默认的视图名，包括路径。默认的前缀、后缀都为空字符串，所以可直接视为视图名就是请求路径。</p>
</blockquote>
<h4 id="8-执行后置拦截器链"><a class="markdownIt-Anchor" href="#8-执行后置拦截器链"></a> 8 执行后置拦截器链</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行拦截器链中的后置拦截</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 获取全部的拦截器</span></span><br><span class="line">   HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">   <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">         interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-处理返回值与响应"><a class="markdownIt-Anchor" href="#9-处理返回值与响应"></a> 9 处理返回值与响应</h4>
<blockquote>
<p>​		通过方法processDispatchResult，处理前面过程中产生的分发结果，在无异常的时候主要的处理对象是处理适配器返回的ModelAndView。发生异常的时候，处理对象为产生的异常，异常处理结果为ModelAndView ，使用此ModelAndView继续执行后序处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于处理适配器调用处理器后适配过的ModelAndView结果，或者发生异常时把异常处理为ModelAndView结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 标记是否为error视图</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 如果出现了异常</span></span><br><span class="line">   <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果异常类型为ModelAndViewDefiningException</span></span><br><span class="line">      <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line"> 	 <span class="comment">// 直接使用异常中封装的ModleAndView作为最终的ModleAndView结果</span></span><br><span class="line">         mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 其他异常类型,先获取处理器</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">          <span class="comment">// 执行process处理器异常方法,获取了处理器异常结果后的得到的ModleAndView结果</span></span><br><span class="line">          mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">          <span class="comment">// 如果mv不为空,则说明返回了包含异常的视图,即返回的视图为异常视图</span></span><br><span class="line">         errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">   <span class="comment">//  如果视图与模型不为空,且视图与模型没有标记为被清理(被清理表示调用过ModelAndView的clear方法,清理后ModelAndView相当于Null)</span></span><br><span class="line">   <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">       <span class="comment">// 视图与模型不为空时,执行渲染视图的操作</span></span><br><span class="line">      render(mv, request, response);</span><br><span class="line">      <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">          <span class="comment">// 如果是异常视图,渲染后需要清楚请求属性的异常信息</span></span><br><span class="line">         WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">// 如果异步请求处理已经开始,则直接返回结束执行</span></span><br><span class="line">   <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">      <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">// 如果处理器执行链不为空时，出发拦截器的完成后方法，这里的完成方法是在请求处理正常完成时执行的。还有异常时执行的完成后方法</span></span><br><span class="line">   <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">      mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>​		在上面的处理过程中，有两个比较重要的方法。第一个是发生异常时，把异常处理为ModelAndView返回值逻辑processHandlerException。第二个是对返回的ModelAndVIew结果进行渲染的逻辑render</p>
</blockquote>
<h5 id="1-处理器异常的处理方法"><a class="markdownIt-Anchor" href="#1-处理器异常的处理方法"></a> 1  处理器异常的处理方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过处理器异常解析器来把产生的异常解析为一个错误视图与模型结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request 请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response 响应</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler 执行的处理器，也与可能为空，如果发生异常时还没有获取处理器。如在多块请求解析的时候发生异常</span></span><br><span class="line"><span class="comment"> * (for example, if multipart resolution failed)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex  在请求处理的过程中发生的异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a corresponding ModelAndView to forward to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if no error ModelAndView found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 成功和错误响应可能使用不同的内容类型</span></span><br><span class="line">   request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check registered HandlerExceptionResolvers...</span></span><br><span class="line">   <span class="type">ModelAndView</span> <span class="variable">exMv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果处理器异常解析器列表不为空</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.handlerExceptionResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (HandlerExceptionResolver resolver : <span class="built_in">this</span>.handlerExceptionResolvers) &#123;</span><br><span class="line">          <span class="comment">// 执行异常处理器拿到结果</span></span><br><span class="line">         exMv = resolver.resolveException(request, response, handler, ex);</span><br><span class="line">          <span class="comment">// 如果不为空，则将此结果作为对异常处理后的ModelAndView结果使用，中断后序遍历动作</span></span><br><span class="line">         <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 如果返回的异常ModelAndView不为null</span></span><br><span class="line">   <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果ModelAndView内部为空 即modle为空view为空</span></span><br><span class="line">      <span class="keyword">if</span> (exMv.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// 设置异常属性到请求属性中</span></span><br><span class="line">         request.setAttribute(EXCEPTION_ATTRIBUTE, ex);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  	<span class="comment">// 如果异常的ModelAndView不包括视图</span></span><br><span class="line">      <span class="keyword">if</span> (!exMv.hasView()) &#123;</span><br><span class="line">          <span class="comment">//采用doDispatch方法中相同的处理逻辑来根据请求获取默认的视图名称</span></span><br><span class="line">         <span class="type">String</span> <span class="variable">defaultViewName</span> <span class="operator">=</span> getDefaultViewName(request);</span><br><span class="line">         <span class="keyword">if</span> (defaultViewName != <span class="literal">null</span>) &#123;</span><br><span class="line">            exMv.setViewName(defaultViewName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Using resolved error view: &quot;</span> + exMv, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Using resolved error view: &quot;</span> + exMv);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 暴露一些异常信息到请求的属性当中</span></span><br><span class="line">      WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());</span><br><span class="line">      <span class="keyword">return</span> exMv;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//如果没有异常处理器解析器，则原封不动的抛出原始异常，交给Web框架做处理</span></span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>​		在把异常解析为ModelAndView结果时，其核心是处理器异常解析器组件。</p>
<p>​		在processDispatchResult方法中，对结果进行统一的处理，进行渲染</p>
</blockquote>
<h5 id="2-渲染"><a class="markdownIt-Anchor" href="#2-渲染"></a> 2 渲染</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对指定的ModelAndView进行渲染</span></span><br><span class="line"><span class="comment"> * 这一步是一个请求的处理过程中的最后一步，其中包含了通过视图名获取视图的逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mv the ModelAndView to render</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP servlet request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP servlet response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException  视图不存在或者不能解析抛出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception 渲染发生任何异常抛出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">// 通过Locale解析器获取请求对应的Locale</span></span><br><span class="line">   <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span></span><br><span class="line">         (<span class="built_in">this</span>.localeResolver != <span class="literal">null</span> ? <span class="built_in">this</span>.localeResolver.resolveLocale(request) : request.getLocale());</span><br><span class="line">    <span class="comment">//设置获取的Locale为相应的Locale</span></span><br><span class="line">   response.setLocale(locale);</span><br><span class="line">	<span class="comment">// 最终获取的视图</span></span><br><span class="line">   View view;</span><br><span class="line">    <span class="comment">// 如果ModelAndView 中视图为视图名，则获取这个名字</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> mv.getViewName();</span><br><span class="line">   <span class="keyword">if</span> (viewName != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 把名字解析为视图</span></span><br><span class="line">      view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">       <span class="comment">// 视图为空的时候同样排除异常</span></span><br><span class="line">      <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Could not resolve view with name &#x27;&quot;</span> + mv.getViewName() +</span><br><span class="line">               <span class="string">&quot;&#x27; in servlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 如果不是视图名，而直接是一个视图类型，则获取视图</span></span><br><span class="line">      view = mv.getView();</span><br><span class="line">       <span class="comment">//视图为空时同样抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (view == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;ModelAndView [&quot;</span> + mv + <span class="string">&quot;] neither contains a view name nor a &quot;</span> +</span><br><span class="line">               <span class="string">&quot;View object in servlet with name &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="comment">//代理调用视图类的渲染方法</span></span><br><span class="line">   <span class="comment">// Delegate to the View object for rendering.</span></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Rendering view [&quot;</span> + view + <span class="string">&quot;] &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 如果ModelAndView中的status部位为空，则设置为相应的状态码@ResponseStatus设置的状态码功能就是通过这里实现的</span></span><br><span class="line">      <span class="keyword">if</span> (mv.getStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">         response.setStatus(mv.getStatus().value());</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 通过视图的渲染方法，每种模板引擎，都有其对应的视图实现，视图渲染对应于模板引擎的渲染模板</span></span><br><span class="line">      view.render(mv.getModelInternal(), request, response);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">&quot;Error rendering view [&quot;</span> + view + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中第一个关键点是通过视图名解析视图的方法resloveViewName，该方法内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> View <span class="title function_">resolveViewName</span><span class="params">(String viewName, <span class="meta">@Nullable</span> Map&lt;String, Object&gt; model,</span></span><br><span class="line"><span class="params">		Locale locale, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 如果视图解析器列表不为空</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.viewResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (ViewResolver viewResolver : <span class="built_in">this</span>.viewResolvers) &#123;</span><br><span class="line">               <span class="comment">//将视图名称解析为视图</span></span><br><span class="line">			<span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">			<span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> view;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<blockquote>
<p>​			这里又通过新的最贱—视图解析器来对视图名称进行解析，得到最终想要的视图，不同的模板引擎有不同的视图解析器，例如Thymeleaf模板引擎，对应的视图解析器为ThymeleafViewResolver，解析逻辑则是通过配置spring.thymeleaf.prefix+视图名+spring.thymeleaf.suffix的形式，从classpath下查找视图资源，并解析为具体的ThymyleafView</p>
<p>​			获取具体的视图之后后续的处理核心就是视图渲染的方法执行。在视图渲染的方法执行过程中，通过Model对模板进行渲染，并吧渲染后的结果写入相应的输出流，最终返回给请求方。不同模板引擎对应着不同的视图，不同的视图，又有自身的渲染方法</p>
</blockquote>
<p>​</p>
<h4 id="10-执行完拦截器链"><a class="markdownIt-Anchor" href="#10-执行完拦截器链"></a> 10  执行完拦截器链</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Exception ex)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 获取全部拦截器</span></span><br><span class="line">   HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">   <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">          <span class="comment">// 执行拦截器的afterCompletion 方法，放在try块中，以保证执行中不再向外抛出异常，因为执行此方法时可能已经发生异常了，而该方法的执行不会再对内部发生的异常进行捕获，避免覆盖上层的异常</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-清理资源"><a class="markdownIt-Anchor" href="#11-清理资源"></a> 11 清理资源</h4>
<blockquote>
<p>​		在finally中，首先对异步请求处理执行了处理器执行链中的afterConcurrentHandlingStarted方法，为异步请求开始执行时添加一些逻辑。</p>
<p>​		除此之外，核心的清理方法是对多块请求的清理。如果是多块请求，且多块请求是被处理过的，则执行多块请求占用资源的清理方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clean up any resources used by the given multipart request (if any).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> MultipartResolver#cleanupMultipart</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">cleanupMultipart</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.multipartResolver != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">MultipartHttpServletRequest</span> <span class="variable">multipartRequest</span> <span class="operator">=</span></span><br><span class="line">            WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class);</span><br><span class="line">      <span class="keyword">if</span> (multipartRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 执行多块请求数据的清理</span></span><br><span class="line">         <span class="built_in">this</span>.multipartResolver.cleanupMultipart(multipartRequest);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结 :</strong></p>
<blockquote>
<p>​		对于默认实现的多块请求解析器StandardServletMultipartResolver,其清理的逻辑是遍历多块数据part，如果多块数据part为文件数据，则执行它们的删除操作，以清理多块数据占用的临时文件</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Curiosity</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lijinzedev.github.io/2020/11/19/DispatcherServlet%E8%AF%A6%E8%A7%A3/">https://lijinzedev.github.io/2020/11/19/DispatcherServlet%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lijinzedev.github.io" target="_blank">Curiosity的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><div class="post_share"><div class="social-share" data-image="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/29/Spring-MVC-%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E7%BB%84%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring MVC 相关组件以及组件初始化</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式——组合模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/12/09/Mybatis源码学习/" title="Mybatis源码学习"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-09</div><div class="title">Mybatis源码学习</div></div></a></div><div><a href="/2020/12/06/Spring-MVC多块请求解析器/" title="Spring MVC多块请求解析器"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-06</div><div class="title">Spring MVC多块请求解析器</div></div></a></div><div><a href="/2020/11/29/Spring-MVC-相关组件以及组件初始化/" title="Spring MVC 相关组件以及组件初始化"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-29</div><div class="title">Spring MVC 相关组件以及组件初始化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://user-images.githubusercontent.com/41108332/105622748-e2c5b580-5e4e-11eb-95c9-b22cdfdd632b.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Curiosity</div><div class="author-info__description">SpringBoot | Mybatis | Java | Mysql</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">155</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">112</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lijinzedev"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lijinzedev" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2533755010@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">万般皆下品,唯有读书高</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#dispatcherservlet-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text"> DispatcherServlet 过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8E%9F%E5%A7%8Bservlet%E5%88%B0springmvc"><span class="toc-number">1.1.</span> <span class="toc-text"> 一 原始Servlet到SpringMvc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-dispatcherservlet%E8%AF%B7%E6%B1%82%E5%85%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text"> 二 DispatcherServlet请求入口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 1 处理请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 2  请求分发概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86%E5%A4%9A%E5%9D%97%E8%AF%B7%E6%B1%82"><span class="toc-number">1.2.2.1.</span> <span class="toc-text"> 1  预处理多块请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text"> 2 查找请求处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E5%A4%84%E7%90%86%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text"> 3 获取处理器适配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A4%84%E7%90%86http%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.2.4.</span> <span class="toc-text"> 4 处理HTTP缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%89%A7%E8%A1%8C%E5%89%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-number">1.2.2.5.</span> <span class="toc-text"> 5 执行前置拦截器链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A4%84%E7%90%86%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.2.6.</span> <span class="toc-text"> 6 处理器适配器执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%BF%94%E5%9B%9E%E8%A7%86%E5%9B%BE%E5%90%8D%E5%A4%84%E7%90%86"><span class="toc-number">1.2.2.7.</span> <span class="toc-text"> 7 返回视图名处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%89%A7%E8%A1%8C%E5%90%8E%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-number">1.2.2.8.</span> <span class="toc-text"> 8 执行后置拦截器链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%A4%84%E7%90%86%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E5%93%8D%E5%BA%94"><span class="toc-number">1.2.2.9.</span> <span class="toc-text"> 9 处理返回值与响应</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86%E5%99%A8%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.9.1.</span> <span class="toc-text"> 1  处理器异常的处理方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B8%B2%E6%9F%93"><span class="toc-number">1.2.2.9.2.</span> <span class="toc-text"> 2 渲染</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE"><span class="toc-number">1.2.2.10.</span> <span class="toc-text"> 10  执行完拦截器链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%B8%85%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">1.2.2.11.</span> <span class="toc-text"> 11 清理资源</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/19/%E5%BC%80%E5%9C%BA/" title="无题"><img data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/07/19/%E5%BC%80%E5%9C%BA/" title="无题">无题</a><time datetime="2024-07-19T06:03:08.609Z" title="发表于 2024-07-19 06:03:08">2024-07-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/18/git-%E6%81%A2%E5%A4%8D%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC/" title="git 恢复文件脚本">git 恢复文件脚本</a><time datetime="2024-07-18T17:43:13.000Z" title="发表于 2024-07-18 17:43:13">2024-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/13/centos7-%E5%AE%89%E8%A3%85datahub/" title="centos7 安装datahub">centos7 安装datahub</a><time datetime="2024-05-13T13:49:07.000Z" title="发表于 2024-05-13 13:49:07">2024-05-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/22/windows-Java%E5%A4%9A%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/" title="windows Java多版本切换">windows Java多版本切换</a><time datetime="2024-04-22T10:37:48.000Z" title="发表于 2024-04-22 10:37:48">2024-04-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/05/Ubuntu%E8%BD%AF%E4%BB%B6%E6%BA%90/" title="Ubuntu软件源">Ubuntu软件源</a><time datetime="2024-04-05T23:33:57.000Z" title="发表于 2024-04-05 23:33:57">2024-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Curiosity</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>