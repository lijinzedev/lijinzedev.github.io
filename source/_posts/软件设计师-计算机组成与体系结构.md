---
title: 软件设计师-计算机组成与体系结构
top: false
cover: false
toc: true
mathjax: true
categories:
  - 软件设计师
tags:
  - 软件设计师
date: 2021-10-09 18:06:15
password:
summary:
---

#  考试大纲

![image-20211008135049194](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110091807647.png)

![image-20211008135405313](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110091807269.png)



# 一、计算机组成与体系结构

## 1.1 数据的展示

![](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081404750.png)

* **原码:**  最高位是符号位，其余低位表示数值的绝对值
* **反码:**  证书的反码与原码相同，负数的反码是其绝对值按位取反（符号位不变）
* **补码: ** 正数的补码和原码相同，负数的补码是其反码末位加1（符号位不变）
* **移码：**补码的符号位按位取反

![image-20211008141047137](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081410160.png)

**理解: **  补码反码有人为定义，所以表示负数如-128 表示为 1000 0000 所以比原码反码负数多一位

![image-20211008141515035](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081415062.png)

**浮点数表示：** 尾数*基数^指数（阶码）^

* 一般尾数用补码，阶码用移码
* 阶码的尾数决定数表示范围，位数越多范围越大
* 尾数的位数决定数的有效精度，位数越多精度越高，尾数位定点小数
* 对阶时，小数向大数看齐
* 对阶是通过较小数的尾数右移实现

逻辑运算

## 1.2 计算机结构

![image-20211008152524418](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081525453.png)

![image-20211009144206545](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110091442616.png)

**运算器：**

① 算数逻辑单元ALU

> 数据的算数运算和逻辑运算

② 累加寄存器AC

> 通用寄存器，为ALU提供一个工作区，用于暂存数据

③ 数据缓冲寄存器DR

> 写内存时，暂存指令或数据

④ 状态条件寄存器PSW

> 存状态标志与控制标志
>

**控制器：**

① 程序计数器 PC

> 存储下一条要执行的指令地址

② 指令寄存器IR

> 存储即将执行的指令

③ 指令译码器ID

> 对指令中的操作码字段进行分析解释

④ 时序部件

> 提供时序控制信号

## 1.3 Flynn分类法

![image-20211008152727335](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081527366.png)

## 1.4 CISC与RISC

![image-20211008153206225](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081532243.png)

**CISC：**复杂，指令数量多，频率差别大，多寻址

**RISC：** 精简，指令数量少，操作寄存器，单周期，少寻址，多通用寄存器，流水线

## 1.5 流水线技术



![image-20211008153529860](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081535887.png)

![image-20211008153935898](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081539921.png)

k代表段数

![image-20211008154847272](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081548302.png)

![image-20211008155114762](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081551786.png)

![image-20211008155213844](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081552866.png)

## 1.7 存储系统

### 1.7.1 层次化存储结构

![image-20211008155611593](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081557119.png)

局部性原理是层次化结构的支撑

* 时间局部性：刚被访问的内容，立即又被访问
* 空间局部性：刚被访问的内容，临近的空间很快被访问

存储器位置

* 内存
* 外存

存取方式

* 按内容存取

  相联存储器（如cache）

* 按地址存取

  随机存取存储器（如内存）

  顺序存取存储器（如磁带 ）

  直接存取存储器（如磁盘）

工作方式

* 随机存取存储器RAM（如内存RAM）
* 只读存储器ROM（如BIOS）

![image-20211008163509231](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110091632210.png)

![image-20211008160121137](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081601163.png)

主存与cache之间的地址映射由硬件直接完成

* 直接相联映像：硬件电路比较简单，但是冲突率很高
* 全相联映射：电路难于设计和实现，只适用于小容量的cache冲突率较低
* 组相联映像：直接相联与全相联折中

地址映像是讲驻村与cache的存储空间划分为若干大小相同的页或者块

例如：某主机内存容量为1GB，划分为2048页，每页512kb，cache容量为8mb，划分为16页，每页512kb

![image-20211008182106870](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110081822395.png)

### 1.7.2 主存编址

**存储单元**

```latex
存储单元个数=最大地址-最小地址+1
```

**编制内容**

`按字编址`：存储体的存储单元是字存储单元，即最小寻址单位是一个字

`按字节编址`: 存储体的存储单元是字节存储单元，即最小寻址单位是一个字节

```
总容量=存储单元个数*编址内容

总片数=总容量/每片的容量
```



## 1.8 总线系统

> 一条总线同一时刻仅仅允许一个设备发送，但允许多个设备接收

总线的分类

* 数据总线（Data Bus ）

在CPU与RAM之间来回传送需要处理的或者需要存储的数据

* 地址总线

用来制定在RAM（Random Access Memory） 之中储存的数据的地址

* 控制总线

将微处理器控制单元的信号，传送到周边设备

## 1.9 可靠性

计算软件可靠性公式

`MTTF/(1+MTTF)`

**串联系统**

**并联系统**

冗余，容错，提高可靠性

![image-20211009172636517](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110091726572.png)

**混合型系统**

![image-20211009172648638](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110091726667.png)

## 1.10 校验码

**奇校验：**整个校验码（有效信息位和校验位）中,"1" 的个数位奇数

**偶校验：** 整个校验码（有效信息位和校验位）中”1" 的个数位偶数

> 奇偶校验,可以检查1位（奇数位的错误），不可以纠错

**CRC校验:** 可以检错不可以纠错

> CRC的编码方法是：在k位信息码之后拼接R位校验码。应用CRC码的关键是如何从k位信息简便的得到r位校验位（编码），以及如何从k+r位信息码判断是否出错

> 把接收到的CRC码用约定的生成多项式G(X)去除（`模二除法`）如果正确，则余数位0；如果某一位出错，则余数部位0，不同的位数出错其余数不同，余数和出错位序号之间有唯一对应关系

**海明校验码：**
海明校验码的原理是：在有效信息位中加入几个校验位形成海明码，使码距比较均匀的拉大，并把海明码的每个二进制位分配到几个奇偶校验组中。当一位出错后，就会引起有关的几个校验位的值发生了变化，这不但可以发现错，还能指出错误的位置，为自动纠错提供了依据

公式

> **2^r^-1>=m+r** 
>
> 通过信息为求除校验位即可
>
> m为信息位

|                 | 校验码位数             | 校验码位置       | 检错             | 纠错     | 校验方式                                                     |
| --------------- | ---------------------- | ---------------- | ---------------- | -------- | ------------------------------------------------------------ |
| 奇偶校验        | 1                      | 一般拼接在头部   | 可校验奇数位出错 | 不可纠错 | 奇校验：最终1的个数是奇数；<br />偶校验：最终1的个数位偶数个 |
| CRC循环冗余校验 | 生成多项式是高次幂决定 | 拼接在信息位尾部 | 可检错           | 不可纠错 | 模二除法求余数，拼接作为校验位                               |
| 海明校验        | 2^r^>=m+r+1            | 插入在信息位中间 | 可检错           | 可纠错   | 分组奇偶校验                                                 |

## 1.11 寻址方式

* 立即寻址方式

> 特点：操作数直接在指令当中，速度快，灵活性差

* 直接寻址方式

> 特点：指令存放的是操作数的地址

* 间接寻址方式

> 特点：指令中存放了一个地址，这个地址对应的内容是操作数的地址

* 寄存器寻址方式

> 特点：寄存器存放操作数

* 寄存器间寻址方式

> 寄存器内存存放的是操作数的地址

## 1.12 数据传输控制方式

* 程序控制（查询）方式：

> 分为无条件传送和程序查询方式两种。方法简单，硬件开销小，但I/O能力不高，严重影响CPU的利用率

* 程序中断方式：

> 与程序控制方式相比，中断方式因为CPU无需等待而提高了传输请求的相应速度（CPU效率得到了很大的提高）

* DMA方式：

> DMA方式是为了在主存与外设之间实现高速、批量数据交换而设置的。DMA方式比程序控制方式和中断方式都搞笑
>
> （DMAC向总线裁决逻辑提出总线请求；`CPU执行完成当前总线周期即可释放总线控制权。`此时DMA相应。通过DMAC通知IO接口开始DMA传输）

* 通道方式
* IO处理机

**中断出来过程**

* CPU无需等待也不必查询IO状态
* 当IO系统准备好以后，发出中断请求信号通知CPU
* CPU接到中断请求后，保存正在执行程序的现场（保存现场）打断的程序当前位置即为断电
* （通过中断向量表）转入IO中的服务程序执行，完成IO系统的数据交换
* 返回被打断的程序继续执行（恢复现场）

## 1.13 性能指标

