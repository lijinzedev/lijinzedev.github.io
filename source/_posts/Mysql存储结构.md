---
title: MySQL存储结构
top: false
cover: false
toc: true
mathjax: true
categories:
  - mysql
tags:
  - mysql
date: 2022-03-21 14:45:01
password:
summary:
---

# MySQL存储结构



## 1 物理存储结构

### 1. 1 数据库文件的存放路径

**MySQL数据库文件的存放路径：/var/lib/mysql/**

```ruby
mysql> show variables like "datadir"
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.01 sec)
```

### 1.2 相关命令目录

相关命令目录：/usr/bin（mysqladmin、mysqlbinlog、mysqldump等命令）和/usr/sbin。

### 1.3 配置文件目录

```ruby
[root@db01 ~]# mysqld --help --verbose |grep my.cnf
/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf
注:
默认情况下，MySQL启动时，会依次读取以上配置文件，如果有重复选项，会以最后一个文件设置的为准。
但是，如果启动时加入了--defaults-file=xxxx时，以上的所有文件都不会读取.
```

## 2 数据库和文件系统的关系

### 2. 1 查看默认数据库

查看一下在我的计算机上当前有哪些数据库：

```mysql
mysql> SHOW DATABASES;
```

可以看到有 4 个数据库是属于MySQL自带的系统数据库。

* `mysql`  MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。

* `information_schema`MySQL 系统自带的数据库，这个数据库保存着MySQL服务器`维护的所有其他数据库的信息`，比如有
  哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为`元数据`。在系统数据库`information_schema`中提供了一些以`innodb_sys`开头的表，用于表示内部系统表。

* `performance_schema`MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以
  用来`监控 MySQL 服务的各类性能指标`。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。
* `sys` MySQL 系统自带的数据库，这个数据库主要是通过`视图`的形式把`information_schema`和`performance_schema`结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。

### 2. 2 数据库在文件系统中的表示

```ruby
❯ ls -all
total 393504
drwxr-xr-x@  29 curiosity  staff       928  3 21 15:54 .
drwxr-xr-x    5 curiosity  staff       160  3 15 17:53 ..
-rw-r-----    1 curiosity  staff         2  3 18 15:47 afde2166ebb9.pid
-rw-r-----    1 curiosity  staff        56  3 18 15:46 auto.cnf
-rw-------    1 curiosity  staff      1680  3 18 15:46 ca-key.pem
-rw-r--r--    1 curiosity  staff      1112  3 18 15:46 ca.pem
-rw-r--r--    1 curiosity  staff      1112  3 18 15:46 client-cert.pem
-rw-------    1 curiosity  staff      1680  3 18 15:46 client-key.pem
-rw-r-----    1 curiosity  staff      1331  3 18 15:47 ib_buffer_pool
-rw-r-----    1 curiosity  staff  50331648  3 21 15:02 ib_logfile0
-rw-r-----    1 curiosity  staff  50331648  3 18 15:46 ib_logfile1
-rw-r-----    1 curiosity  staff  79691776  3 21 15:02 ibdata1
-rw-r-----    1 curiosity  staff  12582912  3 21 14:59 ibtmp1
drwxr-x---   77 curiosity  staff      2464  3 18 15:47 mysql
-rw-r-----    1 curiosity  staff       177  3 18 15:47 mysql-bin.000001
-rw-r-----    1 curiosity  staff       177  3 18 15:47 mysql-bin.000002
-rw-r-----    1 curiosity  staff       539  3 21 15:02 mysql-bin.000003
-rw-r-----    1 curiosity  staff        57  3 18 15:47 mysql-bin.index
-rw-r-----    1 curiosity  staff     14843  3 21 14:58 mysql.error.log
-rw-r-----    1 curiosity  staff   7428294  3 21 16:00 mysql.slow.log
srwxrwxrwx    1 curiosity  staff         0  3 18 15:47 mysql.sock
-rw-------    1 curiosity  staff         2  3 18 15:47 mysql.sock.lock
drwxr-x---   90 curiosity  staff      2880  3 18 15:46 performance_schema
-rw-------    1 curiosity  staff      1680  3 18 15:46 private_key.pem
-rw-r--r--    1 curiosity  staff       452  3 18 15:46 public_key.pem
-rw-r--r--    1 curiosity  staff      1112  3 18 15:46 server-cert.pem
-rw-------    1 curiosity  staff      1680  3 18 15:46 server-key.pem
drwxr-x---  108 curiosity  staff      3456  3 18 15:47 sys
drwxr-x---    5 curiosity  staff       160  3 21 15:02 test
```

这个数据目录下的文件和子目录比较多，除了`information_schema`这个系统数据库外，其他的数据库在`数据目录`下都有对应的子目录。

以我的temp数据库为例，在MySQL 5. 7 中打开：

```ruby

总用量 1144
-rw-r-----. 1 mysql mysql 8658 8 月  18 11 :32 countries.frm
-rw-r-----. 1 mysql mysql 114688 8 月  18 11 :32 countries.ibd
-rw-r-----. 1 mysql mysql 61 8 月  18 11 :32 db.opt
-rw-r-----. 1 mysql mysql 8716 8 月  18 11 :32 departments.frm
-rw-r-----. 1 mysql mysql 147456 8 月  18 11 :32 departments.ibd
-rw-r-----. 1 mysql mysql 3017 8 月  18 11 :32 emp_details_view.frm
-rw-r-----. 1 mysql mysql 8982 8 月  18 11 :32 employees.frm
-rw-r-----. 1 mysql mysql 180224 8 月  18 11 :32 employees.ibd
-rw-r-----. 1 mysql mysql 8660 8 月  18 11 :32 job_grades.frm
-rw-r-----. 1 mysql mysql 98304 8 月  18 11 :32 job_grades.ibd
-rw-r-----. 1 mysql mysql 8736 8 月  18 11 :32 job_history.frm
-rw-r-----. 1 mysql mysql 147456 8 月  18 11 :32 job_history.ibd
-rw-r-----. 1 mysql mysql 8688 8 月  18 11 :32 jobs.frm
-rw-r-----. 1 mysql mysql 114688 8 月  18 11 :32 jobs.ibd
-rw-r-----. 1 mysql mysql 8790 8 月  18 11 :32 locations.frm
-rw-r-----. 1 mysql mysql 131072 8 月  18 11 :32 locations.ibd
-rw-r-----. 1 mysql mysql 8614 8 月  18 11 :32 regions.frm
-rw-r-----. 1 mysql mysql 114688 8 月  18 11 :32 regions.ibd
```

### 2. 3 表在文件系统中的表示

#### 2. 3. 1 InnoDB存储引擎模式

##### 1. 表结构

为了保存表结构，InnoDB在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件，文件名是这样：

```
表名.frm
```

比方说我们在test数据库下创建一个名为  test 的表：

```mysql
mysql> USE test; 
Database changed
mysql> CREATE TABLE test ( 
   ->     c1 INT
   -> );
Query OK, 0 rows affected (0.03 sec)
```

那在数据库  test 对应的子目录下就会创建一个名为  test.frm 的用于描述表结构的文件。.frm文件的格式在不同的平台上都是相同的。这个后缀名为.frm是以二进制格式存储的，我们直接打开是乱码的

##### 2 2. 表中数据和索引

##### ① 系统表空间（system tablespace)

默认情况下，InnoDB会在数据目录下创建一个名为ibdata1、大小为12M的文件，这个文件就是对应的系统表空间在文件系统上的表示。怎么才 12 M？注意这个文件是自扩展文件，当不够用的时候它会自
己增加文件大小。

当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的ibdata1这个文件名难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置文件

```mysql
[server]
innodb_data_file_path=data1:512M;data2:512M:autoextend
```

##### ② 独立表空间(file-per-table tablespace)

在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为`每一个表建立一个独立表空间`，也就是说我们创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个`.ibd`的扩展名而已，所以完整的文件名称长这样：

```
表明.ibd
```

比如我们使用了`独立表空间`去存储test数据库下的test表的话，那么在该表所在数据库对应的test目录下会为test表创建这两个文件夹

```
test.frm
test.ibd
```

其中`test.ibd` 文件就用来存储test标的数据和索引

##### ③ 系统表空间与独立表空间的设置

我们可以自己指定使用 `系统表空间` 还是 `独立表空间` 来存储数据，这个功能由启动参数`innodb_file_per_table` 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动MySQL服务器的时候这样配置：

```bash
[server] 
innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间
```

默认情况：

```ruby
mysql> show variables like 'innodb_file_per_table'; +-----------------------+-------+
| Variable_name | Value | +-----------------------+-------+
| innodb_file_per_table | ON | +-----------------------+-------+
1 row in set (0.01 sec)
```

##### ④ 其他类型的表空间

随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（generaltablespace）、临时表空间（temporary tablespace）等。

#### 2. 3. 2 MyISAM存储引擎模式

##### 1. 表结构

在存储表结构方面，MyISAM和InnoDB一样，也是在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件：

##### 2. 表中数据和索引

在MyISAM中的索引全部都是二级索引，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如test表使用MyISAM存储引擎的话，那么在它所在数据库对应的atguigu目录下会为test表创建这三个文件：

```mysql
test.frm 存储表结构
test.MYD 存储数据 (MYData)
test.MYI 存储索引 (MYIndex)
```

### 2. 4 小结

举例：`数据库a`，`表b`。

 1 、如果表b采用`InnoDB`，data\a中会产生 1 个或者 2 个文件：

* b.frm ：描述表结构文件，字段长度等

* 如果采用系统表空间模式的，数据信息和索引信息都存储在ibdata1中

* 如果采用独立表空间存储模式，data\a中还会产生b.ibd文件（存储数据信息和索引信息）

此外：

① MySQL5.7 中会在data/a的目录下生成`db.opt`文件用于保存数据库的相关配置。比如：字符集、比较规则。而MySQL8.0不再提供db.opt文件。

② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。

2 、如果表b采用`MyISAM`，data\a中会产生 3 个文件：

*  MySQL5.7 中：b.frm：描述表结构文件，字段长度等。

   MySQL8.0 中 b.xxx.sdi：描述表结构文件，字段长度等

* b.MYD(MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式)

* b.MYI(MYIndex)：存放索引信息文件

# MySQL 安装目录的目录结构

| 参数         | 路径                                                       | 解释                                     |
| ------------ | ---------------------------------------------------------- | ---------------------------------------- |
| --basedir    | /usr/bin                                                   | 相关命令目录 mysqladmin、mysqldump等命令 |
| --datadir    | /var/lib/mysql/                                            | MySQL 数据库文件的存放路径               |
| --plugin-dir | /usr/lib64/mysql/plugin                                    | MySQL 插件存放路径                       |
| --log-error  | **/var/log/mysqld.log**                                    | MySQL 日志路径                           |
| --pid-file   | /var/run/mysqld/mysqld.pid                                 | 进程 pid 文件                            |
| --socket     | /var/lib/mysql/mysql.sock                                  | 本地连接时用的unix套接字文件             |
|              | **/usr/share/mysql**                                       | 配置文件目录 MySQL 脚本及配置文件        |
|              | /etc/systemd/system/multi-user.target.wants/mysqld.service | 服务启停相关脚本                         |
|              | **/etc/my.cnf**                                            | MySQL 配置文件                           |

# InnoDB数据存储结构

## 1 数据的存储结构页

索引结构给我们提供了搞笑的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切的说是存储在页结构中。另一方面，索引实在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不同的存储引擎存放的格式一般是不同的，甚至有的存储引擎比如Merrory都不用磁盘来存储数据.

### 1.1 磁盘与内存交互的基本单位: 页

InnoDB将数据划分为若干个页,InnoDb中页默认大小为16kb

以`页`作为磁盘和内存之间交互的`基本单位`，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，`在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）`，`数据库/0操作的最小单位是页`。一个页中可以存储多个行记录。

> 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次IO）只能处理一行数据，效率是很低的

![image-20220321171509748](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203211715914.png)

### 1.2 页结构概述

页a、页b、页c…页这坐页可以`不在物理结构上相连`，只要通过`双向链表`相关联即可。每个数据页中的记录会按照主键值从小到大的顺组成一个`单向链表`，每个数据页都余为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中`使用二分法`快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记灵。

### 1.3页的大小
不同的数据库管理系统（简称DBMS）的页大小不同。比如在MySQL的noDB存储引擎中，默认页的大小是`16KB`，我们可以通过下面的命令来进行查看：

```mysql
mysql>show variables like '%innodb_page_size%';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.03 sec)
```

### 1.4页的上层结构
另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：

![image-20220321173033615](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203211730740.png)

区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配`64个连续的页`。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=`1MB`。

段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页）不过在段中不要求区与区之间是相邻的。`段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在`。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。

表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为==系统表空间==、==用户表空间==、==撤销表空间==、==临时表空间==等。

## 2.页的内部结构

页如果按类型划分的话，常见的有`数据页（保存B+树节点）`、`系统页`、`Undo页`和`事务数据页`等。数据页是我们最常使用的页。

数据页的`16KB`大小的存储空间被划分为七个部分，分别是文件头（File Header））、页头（Page Header）、最大最小记录（Infimum-+supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（PageDirectory）和文件尾（File Tailer）。

页结构的示意图如下所示：

![image-20220321173653368](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203211736465.png)

![image-20220321173728052](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203211737142.png)

我们可以把这7个结构分成3个部分。

### 第1 部分：File Header（文件头部）和File Trailer（文件尾部）

首先是`文件通用部分`，也就是`文件头`和`文件尾`。

### 2.3 从数据页的角度看待B+树如何查询

一棵B+树按照节点类型可以分成两部分：

1. 叶子节点，B+树最底层的节点，节点的高度为0，存储行记录。
2. 非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。

![image-20220322110901954](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203221109075.png)

当我们从页结构来理解B+树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：

**1.B+树是如何进行记录检索的？**

如果通过B+树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用二分查找的方式先找到一个粗略的记录分组，然后再在分组中通过链表遍历的方式查找记录。

**2.普通索引和唯一索引在查询效率上有什么不同？**

我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？

唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为16KB，在一个页中可能存储着上干个记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录”的操作，对于CPU来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。

### 2.4 数据页结构的快速浏览

数据页代表的这块16KB大小的存储空间可以被划分位多个部分

| 名称                 | 中文名             | 占用空间大小 | 简单描述                 |
| -------------------- | ------------------ | ------------ | ------------------------ |
| `File Header`        | 文件头部           | `38`字节     | 页的一些通用信息         |
| `Page Header`        | 页面头部           | `56`字节     | 数据页专有的一些信息     |
| `Infimum + Supremum` | 最小记录和最大记录 | `26`字节     | 两个虚拟的行记录         |
| `User Records`       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| `Free Space`         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| `Page Directory`     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| `File Trailer`       | 文件尾部           | `8`字节      | 校验页是否完整           |

### 2.5 记录在页中的存储

在页的7个组成部分中，我们自己存储的记录会按照我们指定的`行格式`存储到`User Records`部分。但是在一开始生成页的时候，其实并没有`User Records`这个部分，每当我们插入一条记录，都会从`Free Space`部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到`User Records`部分，当`Free Space`部分的空间全部被`User Records`部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

### 2.6 记录头信息的秘密

从图中可以看到，我们特意把`记录头信息`的5个字节的数据给标出来了，说明它很重要，我们再次先把这些`记录头信息`中各个属性的大体意思浏览一下（我们目前使用`Compact`行格式进行演示）：

| 名称           | 大小（单位：bit） | 描述                                                         |
| -------------- | ----------------- | ------------------------------------------------------------ |
| `预留位1`      | `1`               | 没有使用                                                     |
| `预留位2`      | `1`               | 没有使用                                                     |
| `delete_mask`  | `1`               | 标记该记录是否被删除                                         |
| `min_rec_mask` | `1`               | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| `n_owned`      | `4`               | 表示当前记录拥有的记录数                                     |
| `heap_no`      | `13`              | 表示当前记录在记录堆的位置信息                               |
| `record_type`  | `3`               | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录 |
| `next_record`  | `16`              | 表示下一条记录的相对位置                                     |

- delete_mask

  这个属性标记着当前记录是否被删除，占用1个二进制位，值为`0`的时候代表记录并没有被删除，为`1`的时候代表记录被删除掉了。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的`垃圾链表`，在这个链表中的记录占用的空间称之为所谓的`可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

  小贴士： 将这个delete_mask位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段，我们后边在介绍事务的时候会详细唠叨删除操作的详细过程，稍安勿躁。

- min_rec_mask

  B+树的每层非叶子节点中的最小记录都会添加该标记

- heap_no

  这个属性表示当前记录在本`页`中的位置，从图中可以看出来，我们插入的4条记录在本`页`中的位置分别是：`2`、`3`、`4`、`5`。是不是少了点啥？是的，怎么不见`heap_no`值为`0`和`1`的记录呢？

  这其实是设计`InnoDB`的大叔们玩的一个小把戏，他们自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为`伪记录`或者`虚拟记录`。这两个伪记录一个代表`最小记录`，一个代表`最大记录`

  这两条记录的构造十分简单，都是由5字节大小的`记录头信息`和8字节大小的一个固定的部分组成的

  由于这两条记录不是我们自己定义的记录，所以它们并不存放在`页`的`User Records`部分，他们被单独放在一个称为`Infimum + Supremum`的部分，heap_no值分别是0和1，它们位置最靠前

- record_type

  这个属性表示当前记录的类型，一共有4种类型的记录，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的`record_type`值都是`0`，而最小记录和最大记录的`record_type`值分别为`2`和`3`。

- next_record

  表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32字节便是下一条记录的真实数据。`下一条记录`指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 ***Infimum记录（也就是最小记录）*** 的下一条记录就本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 ***Supremum记录（也就是最大记录）***

  我们的记录按照主键从小到大的顺序形成了一个单链表。`最大记录`的`next_record`的值为`0`，这也就是说最大记录是没有`下一条记录`了，它是这个单链表中的最后一个节点。

  从图中可以看出来，删除第2条记录前后主要发生了这些变化：

  - 第2条记录并没有从存储空间中移除，而是把该条记录的`delete_mask`值设置为`1`。
  - 第2条记录的`next_record`值变为了0，意味着该记录没有下一条记录了。
  - 第1条记录的`next_record`指向了第3条记录。
  - 还有一点你可能忽略了，就是`最大记录`的`n_owned`值从`5`变成了`4`，关于这一点的变化我们稍后会详细说明的。

  所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。

  > 小贴士： 你会不会觉得next_record这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？ 因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。而且next_record指针始终是从该位置开始向左读取的第一个属性，这意味着可以非常有效地读取页面中的所有记录，而无需解析变长字段长度列表、NULL值列表之类的可变长度部分。另外，由于从next_record指针处向左读是记录的额外信息部分，所以我们之前说变长字段长度列表、NULL值列表中的信息都是逆序存放的意思大家也就理解了。

  `InnoDB`并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。

  > 小贴士： 当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。

### 2.7 Page Direction（页目录）

记录在页中按照主键值由小到大顺序串联成一个单链表

我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计`InnoDB`的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近`页`的尾部的地方，这个地方就是所谓的`Page Directory`，也就是`页目录`（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为`槽`（英文名：`Slot`），所以这个页面目录就是由`槽`组成的。

设计`InnoDB`的大叔们对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 ***1*** 条记录，最大记录所在的分组拥有的记录条数只能在 ***1~8*** 条之间，剩下的分组中记录的条数范围只能在是 ***4~8*** 条之间。所以分组是按照下边的步骤进行的：

- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从`页目录`中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的`n_owned`值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录的偏移量。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

1. 通过二分法确定该记录所在的槽。
2. 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

### 2.8 Page Header（页面头部）

设计`InnoDB`的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫`Page Header`的部分，它是`页`结构的第二部分，这个部分占用固定的`56`个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：

| 名称                | 占用空间大小 | 描述                                                         |
| ------------------- | ------------ | ------------------------------------------------------------ |
| `PAGE_N_DIR_SLOTS`  | `2`字节      | 在页目录中的槽数量                                           |
| `PAGE_HEAP_TOP`     | `2`字节      | 还未使用的空间最小地址，也就是说从该地址之后就是`Free Space` |
| `PAGE_N_HEAP`       | `2`字节      | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
| `PAGE_FREE`         | `2`字节      | 第一个已经标记为删除的记录地址（各个已删除的记录通过`next_record`也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| `PAGE_GARBAGE`      | `2`字节      | 已删除记录占用的字节数                                       |
| `PAGE_LAST_INSERT`  | `2`字节      | 最后插入记录的位置                                           |
| `PAGE_DIRECTION`    | `2`字节      | 记录插入的方向                                               |
| `PAGE_N_DIRECTION`  | `2`字节      | 一个方向连续插入的记录数量                                   |
| `PAGE_N_RECS`       | `2`字节      | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| `PAGE_MAX_TRX_ID`   | `8`字节      | 修改当前页的最大事务ID，该值仅在二级索引中定义               |
| `PAGE_LEVEL`        | `2`字节      | 当前页在B+树中所处的层级                                     |
| `PAGE_INDEX_ID`     | `8`字节      | 索引ID，表示当前页属于哪个索引                               |
| `PAGE_BTR_SEG_LEAF` | `10`字节     | B+树叶子段的头部信息，仅在B+树的Root页定义                   |
| `PAGE_BTR_SEG_TOP`  | `10`字节     | B+树非叶子段的头部信息，仅在B+树的Root页定义                 |

- `PAGE_DIRECTION`

  假如新插入的一条记录的主键值比上一条记录的主键值比上一条记录大，我们说这条记录的插入方向是右边，反之则是左边。用来表示最后一条记录插入方向的状态就是`PAGE_DIRECTION`。

- `PAGE_N_DIRECTION`

  假设连续几次插入新记录的方向都是一致的，`InnoDB`会把沿着同一个方向插入记录的条数记下来，这个条数就用`PAGE_N_DIRECTION`这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

### 2.9 File Header（文件头部）

上边唠叨的`Page Header`是专门针对`数据页`记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的`File Header`针对各种类型的页都通用，也就是说不同类型的页都会以`File Header`作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦吧啦吧啦～ 这个部分占用固定的`38`个字节，是由下边这些内容组成的：

| 名称                               | 占用空间大小 | 描述                                                         |
| ---------------------------------- | ------------ | ------------------------------------------------------------ |
| `FIL_PAGE_SPACE_OR_CHKSUM`         | `4`字节      | 页的校验和（checksum值）                                     |
| `FIL_PAGE_OFFSET`                  | `4`字节      | 页号                                                         |
| `FIL_PAGE_PREV`                    | `4`字节      | 上一个页的页号                                               |
| `FIL_PAGE_NEXT`                    | `4`字节      | 下一个页的页号                                               |
| `FIL_PAGE_LSN`                     | `8`字节      | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| `FIL_PAGE_TYPE`                    | `2`字节      | 该页的类型                                                   |
| `FIL_PAGE_FILE_FLUSH_LSN`          | `8`字节      | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` | `4`字节      | 页属于哪个表空间                                             |

对照着这个表格，我们看几个目前比较重要的部分：

- `FIL_PAGE_SPACE_OR_CHKSUM`

  这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为`校验和`。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。

- `FIL_PAGE_OFFSET`

  每一个`页`都有一个单独的页号，就跟你的身份证号码一样，`InnoDB`通过页号来可以唯一定位一个`页`。

- `FIL_PAGE_TYPE`

  这个代表当前`页`的类型，我们前边说过，`InnoDB`为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的`数据页`，其实还有很多别的类型的页，具体如下表：

  | 类型名称                  | 十六进制 | 描述                             |
  | ------------------------- | -------- | -------------------------------- |
  | `FIL_PAGE_TYPE_ALLOCATED` | 0x0000   | 最新分配，还没使用               |
  | `FIL_PAGE_UNDO_LOG`       | 0x0002   | Undo日志页                       |
  | `FIL_PAGE_INODE`          | 0x0003   | 段信息节点                       |
  | `FIL_PAGE_IBUF_FREE_LIST` | 0x0004   | Insert Buffer空闲列表            |
  | `FIL_PAGE_IBUF_BITMAP`    | 0x0005   | Insert Buffer位图                |
  | `FIL_PAGE_TYPE_SYS`       | 0x0006   | 系统页                           |
  | `FIL_PAGE_TYPE_TRX_SYS`   | 0x0007   | 事务系统数据                     |
  | `FIL_PAGE_TYPE_FSP_HDR`   | 0x0008   | 表空间头部信息                   |
  | `FIL_PAGE_TYPE_XDES`      | 0x0009   | 扩展描述页                       |
  | `FIL_PAGE_TYPE_BLOB`      | 0x000A   | BLOB页                           |
  | `FIL_PAGE_INDEX`          | 0x45BF   | 索引页，也就是我们所说的`数据页` |

  我们存放记录的数据页的类型其实是`FIL_PAGE_INDEX`，也就是所谓的`索引页`。至于啥是个索引，且听下回分解～

- `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`

  我们前边强调过，`InnoDB`都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大（比方说一张表中可以有成千上万条记录），`InnoDB`可能不可以一次性为这么多数据分配一个非常大的存储空间，如果分散到多个不连续的页中存储的话需要把这些页关联起来，`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的`数据页`（也就是类型为`FIL_PAGE_INDEX`的页）是有这两个属性的，所以所有的数据页其实是一个双链表，就像这样：
  [![image.png](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203221455161.png)](http://gaodongfei.com/upload/2021/06/image-4ccea629851b40b5b25daba98827b2dd.png)

  

### 2.10 File Trailer

我们知道`InnoDB`存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以`页`为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计`InnoDB`的大叔们在每个页的尾部都加了一个`File Trailer`部分，这个部分由`8`个字节组成，可以分成2个小部分：

- 前4个字节代表页的校验和

  这个部分是和`File Header`中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为`File Header`在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在`File Header`中的校验和就代表着已经修改过的页，而在`File Trialer`中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）

  这个部分也是为了校验页的完整性的，只不过我们目前还没说`LSN`是个什么意思，所以大家可以先不用管这个属性。

这个`File Trailer`与`FILE Header`类似，都是所有类型的页通用的。

## 3 InnoDB行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。设计了4种不同类型的行格式：Compact、Redundant、Dynamic、Compressed行格式

> innoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想知道表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘读出来么？不，那样会慢死，InnoDB采用的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16KB。一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

### 3.1 指定行格式的语法

```mysql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

### 3.2 COMPACT行格式

[![image20210620141754238.png](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203221457146.png)](http://gaodongfei.com/upload/2021/06/image-20210620141754238-182ca0297f0b4207a626194a6889c93c.png)


一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两部分。



#### 3.2.1 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是变长字段长度列表，NULL值列表和记录头信息

##### 3.2.1.1 变长字段长度列表

我们知道MySQL支持一些变长的数据类型，比如VARCHR（M）、VARBINARY（M）、各种TEXT类型，我们也可以把拥有这些数据类型的列称为变长字段，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，存储空间分为两部分

1. 真正的数据内容
2. 占用的字节数

在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各类长字段数据占用的字节数按照列的顺序逆序存放。

InnoDB有它一套规则，我们申明一下W、M和L的意思：

1. 假设某个字符集中表示一个字符最多需要使用的字节数为W，也就是使用SHOW CHARSET语句的结果中的Maxlen列，比方说utf8字符集中的w就是3，gbk字符集中的w就是2，ascii字符集中的w就是1
2. 对于变长类型VARCHAR（M）来说，这种类型表示能存储最多M个字符，所以这个类型能表示的字符串最多占用的字节数就是M*W
3. 假设它实际存储的字符串占用的字节数是L

所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：

- 如果M*W<=255，那么使用1个字节来表示真正字符串占用的字节数
- 如果M*W>255，则分为两种情况
  - 如果L <= 127，则用1个字节来表示真正字符串占用的字节数
  - 如果L>127，则用2个字节来表示真正字符串占用的字节数

InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度，如果该字节的第一个位为1，那该字节就是半个字段长度。

变长字段长度列只存储值为非NULL的列内容占用的长度，值为NULL的列的长度是不存储的

小贴士：并不是所有记录都有这个变长字段长度列表部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有

##### 3.2.1.2 NULL值列表

我们知道表中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以Compact行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中

1. 首先统计表中允许存储NULL的列有哪些
2. 如果表中没有允许存储NULL的列，则NULL值列表也就不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列
3. MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0

##### 3.2.1.3 记录头信息

除了变长字段长度列表、NULL值列表之外，还有一个用于描述记录的记录头信息，它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思

[![image20210620164950031.png](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203221457957.png)](http://gaodongfei.com/upload/2021/06/image-20210620164950031-0bedc54a43f0400697dc3e816a38f4f7.png)




这些二进制位代表的详细信息如下表：



| 名称           | 大小（单位：bit） | 描述                                                         |
| -------------- | ----------------- | ------------------------------------------------------------ |
| `预留位1`      | `1`               | 没有使用                                                     |
| `预留位2`      | `1`               | 没有使用                                                     |
| `delete_mask`  | `1`               | 标记该记录是否被删除                                         |
| `min_rec_mask` | `1`               | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| `n_owned`      | `4`               | 表示当前记录拥有的记录数                                     |
| `heap_no`      | `13`              | 表示当前记录在记录堆的位置信息                               |
| `record_type`  | `3`               | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶子节点记录，`2`表示最小记录，`3`表示最大记录 |
| `next_record`  | `16`              | 表示下一条记录的相对位置                                     |

#### 3.2.2 记录的真实数据

MySQL会为每个记录默认的添加一些列

| 列名             | 是否必须 | 占用空间 | 描述                   |
| ---------------- | -------- | -------- | ---------------------- |
| `row_id`         | 否       | `6`字节  | 行ID，唯一标识一条记录 |
| `transaction_id` | 是       | `6`字节  | 事务ID                 |
| `roll_pointer`   | 是       | `7`字节  | 回滚指针               |

> 小贴士： 实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row_id、transaction_id和roll_pointer。

这里需要提一下InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加transacetion_id和roll_pinter这两个列，但是row_id是可选的。这些隐藏列的值不用我们操心，InnoDB存储引擎会自己帮我们生成

#### 3.2.3 CHAR（M）列的存储格式

对于CHAR（M）类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

变长字符集的CHAR（M）类型的列要求至少占用M个字节，而VARCHAR（M）却没有这个要求。比方说对于使用utf8字符集的CHAR（10）的列来说，该列存储的数据字节长度的范围是10-30个字节。一个空字符串也会占10个字节

### 3.3 Redundant行格式

[![image20210620170757929.png](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203221457553.png)](http://gaodongfei.com/upload/2021/06/image-20210620170757929-993e70d1f2b54df2bcc57d7ae218a926.png)



#### 3.3.1 记录的额外信息

- 字段长度偏移列表

  与Compact行格式的开头是变长字段长度列表，而Redundant行格式的开头是字段长度偏移列表。与变长字段长度列表有两出不同

  - 没有了变长两个字，意味着`Redundant`行格式会把该条记录中所有列（包括`隐藏列`）的长度信息都按照逆序存储到`字段长度偏移列表`。
  - 多了个偏移两个字，这意味着计算列值长度的方式不像`Compact`行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。

- 记录头信息

  `Redundant`行格式的记录头信息占用`6`字节，`48`个二进制位，这些二进制位代表的意思如下：

  | 名称              | 大小（单位：bit） | 描述                                                     |
  | ----------------- | ----------------- | -------------------------------------------------------- |
  | `预留位1`         | `1`               | 没有使用                                                 |
  | `预留位2`         | `1`               | 没有使用                                                 |
  | `delete_mask`     | `1`               | 标记该记录是否被删除                                     |
  | `min_rec_mask`    | `1`               | B+树的每层非叶子节点中的最小记录都会添加该标记           |
  | `n_owned`         | `4`               | 表示当前记录拥有的记录数                                 |
  | `heap_no`         | `13`              | 表示当前记录在页面堆的位置信息                           |
  | `n_field`         | `10`              | 表示记录中列的数量                                       |
  | `1byte_offs_flag` | `1`               | 标记字段长度偏移列表中的偏移量是使用1字节还是2字节表示的 |
  | `next_record`     | `16`              | 表示下一条记录的相对位置                                 |

  第一条记录中的头信息是：

  ```
  00 00 10 0F 00 BC
  ```

  根据这六个字节可以计算出各个属性的值，如下：

  ```
  预留位1：0x00
  预留位2：0x00
  delete_mask: 0x00
  min_rec_mask: 0x00
  n_owned: 0x00
  heap_no: 0x02
  n_field: 0x07
  1byte_offs_flag: 0x01
  next_record:0xBC
  ```

  与`Compact`行格式的记录头信息对比来看，有两处不同：

  - `Redundant`行格式多了`n_field`和`1byte_offs_flag`这两个属性。
  - `Redundant`行格式没有`record_type`这个属性。

- `Redundant`行格式中`NULL`值的处理

  因为`Redundant`行格式并没有`NULL值列表`，所以需要别的方式来存储字段的`NULL`值，具体策略如下：

  - 如果该存储`NULL`值的字段是变长数据类型的，则在字段长度偏移列表中记录即可，并不占用记录的真实数据部分。

    比如`record_format_demo`表的`c4`列是`VARCHAR(10)`类型的，而第二条记录的`c4`列存储的是`NULL`值，我们回过头看一下第二条记录的`字段长度偏移列表`如下：

    ```
    A4 A4 1A 17 13 0C 06
    ```

    按照列的顺序排放就是：

    ```
    06 0C 13 17 1A A4 A4
    ```

    可以看到第二条记录的`c4`列的偏移长度和`c3`列的相同都是`A4`，意味着`c4`列的长度为0，也就意味着存储的是`NULL`值。

  - 如果该存储`NULL`值的字段是`CHAR(M)`数据类型的，则将占用记录的真实数据部分，并把该字段对应的数据使用`0x00`字节填充。

    如图第二条记录的`c3`列的值是`NULL`，而`c3`列的类型是`CHAR(10)`，占用记录的真实数据部分10字节，所以我们看到在`Redundant`行格式中使用`0x00000000000000000000`来表示`NULL`值。

除了以上的几点之外，`Redundant`行格式和`Compact`行格式还是大致相同的。

#### 3.3.2 CHAR（M）列的存储格式

我们知道`Compact`行格式在`CHAR(M)`类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况，而在`Redundant`行格式中十分干脆，不管该列使用的字符集是啥，只要是使用`CHAR(M)`类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和`M`的乘积。比方说使用`utf8`字符集的`CHAM(10)`类型的列占用的真实数据空间始终为`30`个字节，使用`gbk`字符集的`CHAM(10)`类型的列占用的真实数据空间始终为`20`个字节。由此可以看出来，使用`Redundant`行格式的`CHAR(M)`类型的列是不会产生碎片的。

#### 3.3.3 行溢出数据

##### 3.3.3.1 VARCHAR（M）最多能存储的数据

从报错信息里可以看出，`MySQL`对一条记录占用的最大存储空间是有限制的，除了`BLOB`或者`TEXT`类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过`65535`个字节。所以`MySQL`服务器建议我们把存储类型改为`TEXT`或者`BLOB`的类型。这个`65535`个字节除了列本身的数据之外，还包括一些其他的数据（`storage overhead`），比如说我们为了存储一个`VARCHAR(M)`类型的列，其实需要占用3部分存储空间：

- 真实数据
- 真实数据占用字节的长度
- `NULL`值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间

如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据，因为真实数据的长度可能占用2个字节，`NULL`值标识需要占用1个字节：

如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那会怎么样呢？来看一下：

从执行结果中可以看出，如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那`M`的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为`NULL`的情况下，`gbk`字符集表示一个字符最多需要`2`个字符，那在该字符集下，`M`的最大取值就是`32766`（也就是：65532/2），也就是说最多能存储`32766`个字符；`utf8`字符集表示一个字符最多需要`3`个字符，那在该字符集下，`M`的最大取值就是`21844`，就是说最多能存储`21844`（也就是：65532/3）个字符。

#### 3.3.4 记录中的数据太多产生的溢出

其中的`REPEAT('a', 65532)`是一个函数调用，它表示生成一个把字符`'a'`重复`65532`次的字符串。前边说过，`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节，而一个`VARCHAR(M)`类型的列就最多可以存储`65532`个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。

在`Compact`和`Reduntant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后`记录的真实数据`处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页

最后需要注意的是，不只是 ***VARCHAR(M)*** 类型的列，其他的 ***TEXT***、***BLOB*** 类型的列在存储数据非常多的时候也会发生`行溢出`。

#### 3.3.5 行溢出的临界点

那发生`行溢出`的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生`行溢出`？

`MySQL`中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要`136`个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。

- 每个记录需要的额外信息是`27`字节。

  这27个字节包括下边这些部分：

  - 2个字节用于存储真实数据的长度
  - 1个字节用于存储列是否是NULL值
  - 5个字节大小的头信息
  - 6个字节的`row_id`列
  - 6个字节的`transaction_id`列
  - 7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，那么发生`行溢出`现象时需要满足这个式子：

```
136 + 2×(27 + n) > 16384
```

求解这个式子得出的解是：`n > 8098`。也就是说如果一个列中存储的数据不大于`8098`个字节，那就不会发生`行溢出`，否则就会发生`行溢出`。不过这个`8098`个字节的结论只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们想一个行中存储了很大的数据时，可能发生`行溢出`的现象。

### 3.4 Dynamic和Compressed行格式

下边要介绍另外两个行格式，`Dynamic`和`Compressed`行格式，我现在使用的`MySQL`版本是`5.7`，它的默认行格式就是`Dynamic`，这俩行格式和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

##### 3.4.1 CHAR(M)中的M值过大的情况

`CHAR(M)`类型的列可以存储的最大字节长度等于该列使用的字符集表示一个字符需要的最大字节数和`M`的乘积。如果某个列使用的是`CHAR(M)`类型，并且它可以存储的最大字节长度超过`768`字节，那么不论我们使用的是上述4种的哪种行格式，`InnoDB`都会把该列当成变长字段看待。比方说采用`utf8mb4`的`CHAR(255)`类型的列将会被当作变长字段看待，因为`4×255 > 768`。

## 4 区、段与碎片区

### 4.1 为什么要有区

B+树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的==物理位置可能离得非常远==。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的==随机1/0==。再一次强调，磁盘的速度和内存的速度差了好几个数量级，==随机工/0是非常慢的==，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I/0。

引入区的概念，一个区就是在物理位置上连续的==64个页==。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=1MB。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是==按照区为单位分配==，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机/O，功大于过！

### 4.2 为什么要有段

对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的==叶子节点==和==非叶子节点==进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个==段（segment）==，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个==叶子节点段==，==一个非叶子节点段==。

除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有==数据段、索引段、回滚段==。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。

在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。

段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。

### 4.3为什么要有碎片区？

默认情况下，一个使用innoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16Kb=1024Kb）存储空间，所以默认情况下一个只存了几条记录的小表也==需要2M的存储空间么？==以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常==纯粹==的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。

为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，innodb提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属
于表空间，并不属于任何一个段。

所以此后为某个段分配存储空间的策略是这样的：

* 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
* 当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。

所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。

## 4.4 区的分类

区大体上可以分为4种类型：

* ==空闲的区（FEE）：==现在还没有用到这个区中的任何页面。

* ==有剩余空间的碎片区（FREE_FRAG）：==表示碎片区中还有可用的页面。

* ==没有剩余空间的碎片区（FULL_FRAG）：==表示碎片区中的所有页面都被使用，没有空闲页面。

* ==附属于某个段的区（FSEG）：==每一个索引都可以分为叶子节点段和非叶子节点段。

处于==FREE、FREE_FRAG==以及==FULL_FRAG==这三种状态的区都是独立的，直属于表空间。而处于FSEG状态的区是
  附属于某个段的。

> 如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于FSEG的区全都隶属于某个段，而处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。

## 5 表空间

表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表腔间中。

表空间是一个==逻辑容器==，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间（Systemtablespace）、==独立表空间==（File-per-table tablespace）、==撤销表空间==（Undo Tablespace）和==临时表空间==（Temporary Tablespace）等。

### 5.1独立表空间

独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间（即：单表）可以在不同的数据库之间进行迁移。

空间可以回收（DROP TABLE操作可自动回收表空间；其他情况，表空间不能自己回收）。如果对于统计分析或是日志表，删除大量数据后可以通过：`alter table TableName engines=innodb；`回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。

**独立表空间结构**

**真实表空间对应的文件大小**

我们到数据目录里看，会发现一个新建的表对应的.ibd文件只占用了96K，才6个页面大小（MSQL5.7中），这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些.b文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。

**查看InnoDB的表空间类型：**

```mysql
 show variables like innodb_file_per_table';
```

### 5.2 系统表空间

系统表空间的结构和独立表空间基本类似，只不过由于整MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。
**InnoDB数据字典**

每当我们向一个表中插入一条记录的时候，MySQL校验过程如下：

先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：

* 某个表属于哪个表空间，表里边有多少列
* 表对应的每一个列的类型是什么
* 该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面
* 该表有哪些外键，外键对应哪个表的哪些列某个表空间对应文件系统上文件路径是什么

上述这些数据并不是我们使用INSERT语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为元数据。InnoDB存储引擎特意定义了一些列的内部系统表（internalsystem table）来记录这些这些元数据：

![image-20220322154709685](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202203221547228.png)注意：用户是不能直接访问InnoDB的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库information_schema中提供了一些以innodb_sys开头的表：

