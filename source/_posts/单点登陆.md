---
title: 单点登陆
top: false
cover: false
toc: true
mathjax: true
categories:
  - 系统集成
tags:
  - 系统集成
date: 2021-09-15 17:56:56
password:
summary:
---

# 单点登录

## 一、简介

> ​		单点登录：Single Sign On，它的出现致力于提供分布式项目中的用户登录和注销操作，使之只需要一次登陆即可在所有其他系统中无需登陆。注销同理，在任一系统中注销其他系统也会退出登陆。这样各个系统无需有登陆退出功能，统一进行用户授权。 比如阿里系的**淘宝和天猫**，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝无需再进行登录，一次授权，多个应用使用。

在SSO体系中，主要包括三部分：

1. User用户（多个）
2. Web 应用（多个）
3. SSO 认证中心（ 1 个）

而SSO的实现基本核心原则如下：

- 所有的登录授权都在 SSO 认证中心进行
- SSO 认证中心通过一些方法来告诉 Web 应用当前访问用户究竟是不是已通过认证的用户
- SSO 认证中心和所有的 Web 应用建立一种信任关系， SSO 认证中心对用户身份正确性的判断会通过某种方法告之 Web 应用，而且判断结果必须被 Web 应用信任。

## 二、单系统回顾

​		在了解SSO的实现之前，先对以往的单系统用户身份授权认证的实现进行简单回顾。
首先，HTTP是无状态的协议，服务器无法直接确认用户的信息。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是Cookie。

---

​		如果说Cookie是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。Session相当于在服务器中建立了一份“客户明细表”。

---

​		HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户。于是乎：服务器向用户浏览器发送了一个名为JESSIONID的Cookie，它的值是Session的id值。其实Session是依据Cookie来识别是否是同一个用户。

---

**所以，一般我们单系统实现登录会这样做：**

- **登录**：将用户信息保存在Session对象中
  如果在Session对象中能查到，说明已经登录;
  如果在Session对象中查不到，说明没登录（或者已经退出了登录）
- **注销**（退出登录）：从Session中删除用户的信息
- **记住我**（关闭掉浏览器后，重新打开浏览器还能保持登录状态）：配合Cookie来用

![](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202109151747264.png)

## 三、技术实现

### 3.1 基于Cookie的单点登录

​		这是最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。 用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。

---

**不难发现以上方式把信任存储在客户端的Cookie中，有以下两个问题**

**1 Cookie不安全**

​		通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie
​		的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。

**2 不能跨域实现免登**

​		不能跨域实现免登更是硬伤。因此，有了基于Session的单点登录

### 3.2 基于Session的单点登录

​		Session解决了Cookie不能跨域的问题，但也存在其他问题。早期的单体应用使用Session实现单点登录，但现在大部分情况下都需要集群，由于存在多台服务器，Session在多台服务器之间是不共享的，因此，还需解决`Session共享的问题`

---

**解决系统之间的 Session 不共享问题有以下几种方案：**

* Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】
* 根据请求的IP进行Hash映射到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】
* 分布式Session，即把Session数据放在Redis中（使用Redis模拟Session）【建议】

---

**由上可以得出，当前大部分单点登录系统运行流程如下图**

![流程图](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202109151746779.png)

1. 用户登录系统应用1，发现未登录，重定向到认证系统登录，认证系统验证用户名和密码等信息通过，返回用户一个ticket，并将Session存入Redis或其他缓存容器
2. 用户携带ticket登录系统应用2，应用系统2到认证系统进行ticket验证，若存在该ticket对应的Session，则登录成功
3. 用户携带ticket登录系统应用3，应用系统3到认证系统进行ticket验证，若存在该ticket对应的Session，则登录成功

## 四、常见方案

### 4.1 CAS

   CAS(Central Authentication Service) 是 Yale 大学发起的一个开源项目，是单点登录的一种现方式，分为CAS服务端和CAS客户端![](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202109151751288.png)

**具体流程如下：**

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。

2. 跳转到CAS server，即SSO登录系统，以后图中的CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。

3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。

4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。

5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。

6. SSO系统返回验证结果

7. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

8. 用户访问app2系统，app2系统没有登录，跳转到SSO。
9. 由于SSO已经登录了，不需要重新登录认证。
10. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
11. app2拿到ST，后台访问SSO，验证ST是否有效。
12. SSO系统返回验证结果
13. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。
    这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。

### 4.2 oauth2（第三方登录授权）

​    OAuth（Open Authorization，开放授权）是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息

​		主要应用于第三方应用授权登录：在APP或者网页接入一些第三方应用时，时常会需要用户登录另一个合作平台，比如QQ，微博，微信的授权登录,第三方应用通过oauth2方式获取用户信息

![](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202109151751613.png)

**详细步骤如下（以微信登录为例）：**

1. 用户访问第三方网站,第三方应用需要用户登录验证,用户选择微信授权登录

2. 第三方应用发起微信登录授权请求

3. 微信服务器拉起用户授权确认页面

4. 用户授权通过

5. 微信发送请求到第三方应用redirctUrl(第2步填写redirct_uri参数),返回凭证code与state(第2步自定义)

6. 第三方应用获取到code之后,根据code获取accessToken

7. 根据accessToken获取用户信息

8. 对用户信息进行处理(用户是否第一次登录,保存用户信息,自定义token,session处理等)

9. 返回结果(步骤1对应url或者重定向到首页)

### 4.3JWT（客户端token）

难度较大，需要了解很多协议

---

Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标（(RFC7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。
基于JWT认证协议，自己开发SSO服务和权限控制。

----

以上为常见的单点登录解决方案，当然，在使用的同时也会和其他的权限授权认证的安全框架整合实现。

**常见的安全框架有**

* Spring Security
* Shiro