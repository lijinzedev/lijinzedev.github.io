---
title: 设计模式——组合模式
top: false
cover: false
toc: true
mathjax: true
date: 2020-11-15 16:27:56
password:
summary:
categories: 
           - 设计模式 - 结构型设计模式
tags:
           - 设计模式 - 结构型设计模式
---

# 组合模式

## 一 概念

> 组合（Composite Pattern）模式的定义：有时又叫作整体-部分（Part-Whole）模式，它是一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型[设计模式](http://c.biancheng.net/design_pattern/)。

###  1 结构图

> 由下图可以看出，其实根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用；而叶子节点与树枝节点在语义上不属于用一种类型。但是在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。

**这样，在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，给用户的使用带来极大的便利。**

![组合模式结构图](image-20201115164732400.png)

### 2 主要优点

1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；

**例如：**`SpringMvc当中的参数解析器`

![Mvc参数解析器](image-20201115160159399.png)



2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；

### 3 主要缺点

1. 设计较复杂，客户端需要花更多时间理清类之间的层次关系；
2. 不容易限制容器中的构件；
3. 不容易用继承的方法来增加构件的新功能；



### 4 分类

* 安全性

> ​		在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。

* 非安全

> ​		在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。

## 二 应用

### 1 权限管理——菜单与功能点

> 权限管理,菜单分为一级菜单、二级菜单、三级菜单、四级菜单、功能点

### 2 结构图

![结构图](image-20201115155505436.png)

### 3 数据库表

![菜单功能点数据库](image-20201115175513119.png)

> ​	关于这里数据库表的设计，不做讨论，因为不同的设计，处理方式不同，之阐述对于组合模式的一个实例

### 4 构建组合树关系



```java
/**
 * @author: Curiosity
 * @Date: 2020/11/15 17:59
 * @Description: 抽象菜单，祖先类
 */
@Data
public abstract class AbstractMenu {
    protected String id;
    protected String name;
    protected String path;
}

/**
 * @author: Curiosity
 * @Date: 2020/11/15 18:01
 * @Description: 菜单类对应树杈
 */
public class Menu extends AbstractMenu {
    List<AbstractMenu> menus = new ArrayList<>();

    public void addMenu(AbstractMenu abstractMenu) {
        menus.add(abstractMenu);
    }

}


/**
 * @author: Curiosity
 * @Date: 2020/11/15 18:05
 * @Description: 功能点类对应树叶
 */
public class Function extends AbstractMenu {
    private String funcation;
}

/**
 * @author: Curiosity
 * @Date: 2020/11/15 18:11
 * @Description:
 */
public class Build {
    @Autowired
    MenuDao menuDao;
    @Autowired
    FunctionDao functionDao;

    private void buildTree(Menu rootMenu) {
        List<Menu> menus = menuDao.findMenusByMenusId(rootMenu.getId());

        for (Menu menu : menus) {
            rootMenu.addMenu(menu);
            buildTree(menu);
        }
        List<Function> functions = functionDao.findFunctionByMenusId(rootMenu.getId());
        for (Function function : functions) {
            rootMenu.addMenu(function);
        }
    }

}

```

