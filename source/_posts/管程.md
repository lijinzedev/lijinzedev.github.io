---
title: 管程
top: false
cover: false
toc: true
mathjax: true
categories:
  - 高并发 
  - 并发编程专题
tags:
  - 高并发 
  - 并发编程专题
date: 2022-04-11 15:04:37
password:
summary:
---

https://www.coursera.org/lecture/os-pku/guan-cheng-de-ji-ben-gai-nian-PLIcP?isNewUser=true

# 管程

## 为什么会出现管程

> 信号量机制的不足：程序编写苦难、容易出错，如果没有合理安排PV操作的位置，就会导致出错

**解决：**

* Brinch Hansen(1973)
* Hoare (1974)

## 管程的定义

* 是一个特殊的模块
* 有一个名字
* 由关于共享资源的数据结构以及在其上操作的一组过程组合



**进程与管程**

> 进程只能通过调用管程中的过程来间接地访问管程中的数据结构

## 管程要保证什么

作为一个同步机制，管程要解决两个问题

1. 互斥

   管程是互斥进入的，为了保证管程中数据结构的完整性

   **管程的互斥性是由编译器负责保证的**

2. 同步

   管程中设置**条件变量，以及等待(wait)/唤醒操作(signal)**

   可以让一个进程或线程在条件变量上等待（此时，应先释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒

## 应用管程时遇到的问题

是否会出现这样一种场景，有多个进程同时在管程中出现

**场景：**

当一个进入管程的进程执行等待操作时，它应当释放管程的互斥权

当后面进入管程的进程执行唤醒操作时（例如P唤醒Q）,管程汇总便存在两个同时处于活动状态的进程

**解决方法：**

三种处理方法

当Q进程先进来，P进程后进来

1. P等待Q执行 `Hoare管程`
2. Q等待P继续执行 在另一个队列等待 `MESA管程`
3. 规定唤醒操作为管程中最后一个可执行的操作 `Hansen 管程`

# HOARE管程

![image-20220412214830463](https://user-images.githubusercontent.com/41108332/162978007-57d663cc-c35e-4b29-9631-b994c340f6d3.png)

> 管程是管理资源的，资源是某种数据结构，对资源的各种操作由若干个过程来表示，管程是互斥进入的，一个进程调用了管程的某一个操作，那么其他的还想进管程的，需要在管程外面等待，但是进入管程的进程，在对管程操作的过程中，发现资源不成熟（例如生产者想调用insert过程把数据放到缓冲区里面，如果缓冲区慢了，生产者就需要等），会出现等待。
>
> 为等待不同条件的进程设置了条件变量，进程在条件变量上等待，一个进程调用wait操作会等到条件变量上，当一个进程等待到条件变量上，他会放开管程的互斥权，如果后面的进程调用了管程的过程进行操作，操作过程中，发现条件成熟了，会调用signal函数，唤醒等待条件变量上的进程，如果唤醒刚刚等待的进程，那么管程中就存在两个进程了，按照hoare管程的语义，后面的进程唤醒前面的进程，前面的进程执行，后面的进程等待，等待的队列为一个紧急等待队列，前面的进程继续执行

* 因为管程是互斥进入的，所以当一个进程试图进入一个被占用的管程时，应当在管程的入口处等待
  * 为此，管程的入口设置了一个等待队列，称作入口等待队列

* 如果进程P唤醒进程Q则P等待Q执行;如果进程Q之执行中又唤醒了R,则Q等待R执行;......如此,在管城内部可能会出现多个等待进程
  * 在管程内需要设置一个进程等待队列,成为紧急等待队列,紧急等待队列的优先级高于入口等待队列的优先级

## 条件变量

> 在管程内部说名和使用一种特殊类型的变量

* var c: condition
* 对于条件变量,可以执行wati和signal操作

`wait(c)`

> 如果**紧急等待队列非空**,则唤醒第一个等待者;否则释放管程的互斥全,执行此操作的进程进入c链(条件变量)的末尾

`singal`

如果c链为空,则相当于空操作,执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的末尾

# 管程的应用

管程实现的两个主要途径：

* 直接构造（效率高）
* 间接构造
  * 用某种已经实现的同步机制去构造。例如信号量以及PV操作构造管程

## 管程解决生产者消费者问题

```c
monitor ProducerConsumer
	//定义条件变量
	condition full,empty;
	// 记录缓冲区数据
	integer count;
	
	// 向缓冲区里面送数据
	procedure insert(item: integer)
	begin
		// 缓冲区满了就wait wait到full这个条件变量上
		if count == N then wait(full);
		insert_item(item);count++;
		// 缓冲区可以放数据进行唤醒
		if count==1 then signal(empty)
		
	end;
	
	// 向缓冲区里面区数据
	function remove:Integer
	begin
		// 如果没有数据可取，等在条件变量上
		if count ==0 then wait(empty);
		remove =remove_item;count--;
		// 如果缓冲区不慢，就唤醒
		if count==N-1 then signal(full);
	end;
	// 初始化为0
	count:=0;
end monitor;
```

```c
poricedure producer
begin
	while true do
    begin
    	item = produce_item
    	ProducerConsumer.insert(item)
    end
end;

procedure consumer;
begin
	while true do
	begin
		ProducerConsumer.remove(item)
		consume_item(item)
	end
end;
```

# ![image](https://user-images.githubusercontent.com/41108332/162983782-404a7762-f6f2-43dd-9e44-69199aadbbcc.png)![image](https://user-images.githubusercontent.com/41108332/162984124-ede53dd7-7508-4f11-ac76-f563dc3c4609.png)MESA管程

> Lampson和Redell,Mesa语言(1980)

Hoare管程的一个缺点

> P进程唤醒Q，P进程等待，Q进程执行，会进行一次进程切换，当Q进程执行完了，P进程再次调度，造成两次额外的进程切换

解决：

* signal->notify
* notify:当一个正在观众的进程执行notify（x）时，它使得x条件队列得到通知，发信号的进程继续执行

## Notify要注意的问题

* notify的结果:谓语条件队列头的进程在将来合适的时候且当处理器可用时恢复执行

* 由于不能保证在它之前没有其他的进程进入管程，因而这个进程必须重新检查条件

  * 用while循环取代if语句

* 导致对条件变量至少多一次额外的测试（但不在有额外的进程切换），并且对等待的进程在notify之后何时运行没有任何限制

  ![image](https://user-images.githubusercontent.com/41108332/162987872-414c9b79-dc50-484c-a9d5-0baf4fcaf6b9.png)

**对notify的一个很有用的改进**

* 给每个条件原语关联一个监视计时器，不论是否被通知，一个等待时间超时的进程将被设为就绪态
* 当该进程被跳读执行时，会再次检查相关条件吗，如果条件满足则继续执行

**超时可以防止以下情况的发生**

* 当某些进程在产生相关的条件的信号之前失败时，等待该条件的进程就会被为限制地推迟执行而处于饥饿状态

boradcast: 使所有在该条件上的等待的进程都被释放并进入就绪队列

* 当一个进程不知道有多少进程将被激活时。这种方式非常方便
* 当一个进程难以准确的判定将激活哪个进程时，也可以使用广播

## Hoare管程与Mesa 管程的比较

Mesa管程优于Hoare管程之处在于Mesa管程错误少

在MEsa管程中，由于每个过程在接受到信号后都重新检查管程变量，并且由于使用了while结构，一个进程不正确的broadcast广播或发型好notify，不会导致收到i性能好的程序出错

收到信号的程序将检查相关的变量，如果期望的条件没有满足，他会重新继续等待

# 小结

管程：抽象数据类型

有一个明确的定义的操作集合，通过它且只有通过它才能操纵该数据类型的实例

实现过程结构必须保证下面几点：

1. 只能通过管程的某个过程才能访问资源
2. 管程是互斥的。，某个时刻只能有一个进程或线程调用管程中的过程

条件变量：为提供进程与其他继承通信或同步引入