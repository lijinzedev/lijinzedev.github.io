---
title: 软件设计师-操作系统
top: false
cover: false
toc: true
mathjax: true
categories:
  - 软件设计师
tags:
  - 软件设计师
date: 2021-10-11 10:38:11
password:
summary:
---



# 操作系统

* 管理系统硬件、软件、数据资源
* 控制程序进行
* 人机之间的接口
* 应用软件与硬件之间的接口

**管理职能**

* 进程管理
  * 进程的状态
  * ==前趋图==
  * ==PV操作==
  * 死锁问题
* 存储管理
  * ==段页式存储==
  * 页面置换算法
* 文档管理
  * 索引文件
  * ==位示图==
* 作业管理
* 设备管理
* 微内核操作系统
  * 虚设备与SPOOLING奇数



# 一、进程管理

## 1.1 进程状态

![进程的状态](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111345201.png)

### 1.1.1 前趋图

> 用来表示哪些任务可以并行执行，哪些任务可之间有顺序关系

![image-20211013141746644](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110131418847.png)

### 1.1.2 进程资源图

* 进程资源图：用来表示进程和资源之间的分配和请求关系

![image-20211013141946515](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110131419549.png)

![image-20211013142219490](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110131422529.png)

##  1.2 进程的同步与互斥

![image-20211013150717311](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110131507369.png)

* 直接制约关系
* 间接制约关系
* 临界资源

![image-20211011140331921](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111403956.png)

## 1.3 PV操作

* **临界资源：**诸进程间需要护持方式对其进行共享的资源，如打印接、磁带机等

* **临界区：** 每个进程中访问临界资源的那段代码位临界区

* **信号量：**是一种特殊的变量

  <!--P是荷兰语Passeren，V是荷兰语Verhoog-->

![image-20211011140733579](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111407618.png)

P：申请资源

V：释放资源

S：资源总数

![image-20211011141237707](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111412746.png)



## 1.4 死锁问题

> 进程管理是操作系统的核心，如果设计不当，就会出现死锁的问题。如果一个进程在等待一件不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁问题，就会造成系统死锁1
>

最小资源：==n  * （k-1）+1==

发生死锁的最大资源是:==n *(k-1)==

对于M个进程，每个需要T个资源，共有N个资源，为不发生死锁，则应当满足：N > M * (T-1)，即N最小为 N = M * (T - 1) +1。

解析：最坏的资源分配策略，即给每个进程平均分配资源，当资源不足时，易导致多个进程进入阻塞。 

​        此时最坏的情况，即每个进程都差一个资源达成需求，但资源已分配完毕。 

​       若此时再添加一个资源，那么至少会有一个进程得到所需资源，进而从阻塞的状态释放，当它执行完毕，释放它请求的资源，便会多出N个待分配资源，此时可满足其他进程的的资源需求

![image-20211011152438407](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111524458.png)

**死锁的预防**

> 打破以下四个条件即可完成死锁的预防

* 互斥
* 环路等待
* 不剥夺
* 保持和等待

**死锁的避免**

* 有序资源分配法
* 银行家算法

> 当一个进程对资源的最大需求量不超过系统中的资源数时可以接纳该进程
>
> 进程可以分期请求资源，但请求的总数不能超过最大需求量
>
> 当系统现有资源不能满足进程尚需资源数时，对进程的请求可以推迟分配，但总能使进程在悠闲地时间里得到资源

# 二、存储管理

## 2.1 分区存储组织
![image-20211011153922424](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111539467.png)

## 2.2 页面置换算法

* 最优（Optimal，OPT）算法
* 随机（RAND）算法
* 先进先出（FIFO）算法，有可能产生”抖动“。例如，432143546215序列，用3个页面，比4个缺页要少
* 最近最少使用（LRU）算法，不会”抖动“

![image-20211011160133147](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111601192.png)

> 不使用块表，访问某一特定页面，要先查找页表得到页号，然后根据页号查找内容访问两次内存
>
> 无论指令是否在两个页中，指令会一次性读入，指令产生一次缺页中断
>
> 数据产生两次缺页中断

## 2.3 页式存储组织

**页式存储：**将程序与内存划分为同样大小的块，以页为单位将程序调入内存

逻辑地址=页号+页内地址

物理地址=页帧号(快号)+页内地址

优点：利用率高、碎片小、分配及管理简单

缺点：增加系统开销可能产生抖动现象

## 2.4 段式存储组织

![image-20211013171117017](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110131711113.png)

## 2.5 快表

* 是一块小容量的相联寄存器，由快速存储器组成，按内容访问，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号
* 快表示将页表存于cache中，慢表示将页表存在内存上
* 因此慢表需要访问两次内存才能取出页

# 三、文件管理

## 3.1 索引文件结构

![image-20211011160709826](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111607864.png)

假如一个物理盘块是4k

0-9索引节点存储容量：40k

10号索引节点存储容量：1024 x 4k

11号索引节点存储容量：1024x1024x4k

12号索引节点存储容量：1024x1024x1024x4k

每一个索引快可以存放的地址数=磁盘索引快大小/每个地址项大小



## 3.2 文件和树形目录结构

**文件属性**

* R 只读文件属性
* A存档属性

* S 系统文件
* H 隐藏文件

**文件名的组成**

* 驱动器号
* 路径
* 主文件名
* 扩展名

## 3.3 空闲存储空间的管理

![image-20211011162602225](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111626262.png)

* 空闲区表法
* 空闲链表法
* 位示图法（bitmap）

> 位示图大小=磁盘物理块数/字长

* 成组链接法

![image-20211011163203386](../../../Library/Application%20Support/typora-user-images/image-20211011163203386.png)

![image-20211011163309743](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111633773.png)

> 注意：第多少字从1开始算
>
> 第几个位置从0位开始算

## 3.4 磁盘结构

* 磁盘有正反两个盘面，每个盘面有多个同心圆，每个同心圆是一个磁道，每个同心圆又被划分位多个扇区，数据就被存放在一个个扇区中
* 读取数据时，磁头首先要寻找到对应的磁道，然后等待磁盘进行进行周期旋转，旋转到指定的扇区，才能读取到对应的数据，因此，会产生寻道时间和==等待时间==，就是磁头移动到磁道所需要的时间和等待读写的扇区转到磁头下方所用的时间。其中寻道时间耗时最长，寻道时间的调度算法如下

**寻道时间的调度算法：**

![image-20211013180014731](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110131800787.png)

# 四、设备管理

**设备的分类方式:**

* 按照组织分类
  * 块设备
  * 字符设备
* 资源分配角度分配
  * 独占设备
  * 共享设备
  * 虚拟设备
* 数据传输速率分类
  * 低俗设备
  * 中速设备
  * 高速设备

**IO软件层次结构**

![image-20211013173713305](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110131737355.png)

## 4.1 数据传输控制方式

![image-20211013173904506](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110131739573.png)

* **程序控制方式**（程序查询方式）
* **程序中断方式**
* **DMA方式**
* 通道（不重要）
* 输入输出处理机（不重要）

![image-20211011163505714](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111635749.png)

## 4.2 虚设备与SPOOLING技术

![image-20211011163613641](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111636669.png)

## 4.3 微内核操作系统
![image-20211011163906881](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110111639270.png)

##  4.4 嵌入式操作系统

* 嵌入式操作系统特点：微型化、代码质量高、专业化、实时性强、可裁剪配置

* 实时嵌入式操作系统的内核服务：异常和中断、计时器、IO管理。

* 常见的嵌入式RTOS（实时操作系统）：VxWorks、RT-Linux、QNX、pSOS

* 嵌入式系统初始化过程按照自底向上、从硬件到软件的次序依次为

  * 片级初始化->扳级初始化->系统初始化

    > 芯片级是微处理器的初始化，扳卡级是其他硬件设备初始化，系统级初始化就是软件及操作系统初始化
