---
title: 软件设计师-数据库
top: false
cover: false
toc: true
mathjax: true
categories:
  - 软件设计师
tags:
  - 软件设计师
date: 2021-10-18 16:45:44
password:
summary:
---

# 数据库技术基础

> 数据库DBS；是一个采用了数据库技术，有组织的、动态的存储大量相关技术

![image-20211018170546690](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110181705784.png)

# 一、三级模式-两级映像

![image-20211019172717624](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110191727728.png)

# 二、数据库设计

![image-20211019173156584](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110191731649.png)

# 三、E-R模型

![image-20211019173538701](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110191735752.png)

# 四、关系模型

![image-20211019173612020](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110191736051.png)

# 五、关系代数的运算

- ### 选择运算（select）==>相当于SQL语句中的WHERE子句的职能

  - #### 格式：σ选择谓词(关系)

  - 举个栗子：

    - σSAL>1000(EMP)
    - 上式表示取出查询工资大于1000的所有员工的信息
    - 等价于下面的SQL语句

    

    ```sql
    SELECT *
    FROM EMP
    WHERE SAL > 1000
    ```

  - 选择谓词的分类

    - 比较：=、≠、<、≤、>和≥
    - 连词：and(∧)、or(∨)和not(¬)==>可以将多个谓词合并成一个大的谓词
    - 可以包括两个属性（字段的比较）：σCOMM>SAL(EMP)表示抽成大于工资的人

- ### 投影运算（project）==>相当于SQL语句中的SELECT子句的职能

  - #### 格式：∏字段序列(关系)

  - 举个栗子

    - ∏ENAME,SAL(EMP)
    - 上式表示查看所有员工的姓名和工资
    - 等价于下面的SQL语句

    

    ```sql
    SELECT ENAME, SAL
    FROM EMP
    ```

- ### 关系的组合运算==>就像SQL中select、where子句那样的组合效果

  - 举个栗子

    - ∏ENAME,SAL(σSAL>1000(EMP))
    - 上面的式子求出了所有工资大于1000的员工的名字和工资(实际上就是将**σSAL>1000(EMP)**执行的结果当做一个临时的关系，参与了投影运算得到的)
    - 等价于下面的SQL语句

    

    ```sql
    SELECT ENAME, SAL
    FROM EMP
    WHERE SAL > 1000
    ```

  - 事实关系的组合运算就是那么简单，分析的时候把每个简单运算的结果当做一个新的关系参与后面的运算，这样一层层剥开来，再复杂的语句也变得容易分析

- ### 并运算（union）==>相当于SQL中UNION关键字的职能

  - #### 格式：（关系r）∪（关系s）

  - 举个栗子

    - ∏ENAME,SAL(σSAL>1000(EMP)) ∪ ∏ENAME,SAL(σCOMM>300(EMP))
    - 上面的式子求出了所有工资大于1000或抽成大于300的员工的姓名和工资，等价于下面的SQL语句

    

    ```sql
    SELECT ENAME, SAL
    FROM EMP
    WHERE SAL > 1000
    UNION
    SELECT ENAME, SAL
    FROM EMP
    WHERE COMM > 300
    ```

  - 几点需要额外注意的

    ：

    - 此处的并运算是集合运算，所以结果是去重的，结果集中不存在重复的元组（***而在SQL语句中，指定UNION ALL是可以保留重复的\***）
    - 关系r与关系s必须是同元的，即它们的属性的数目要求必须相同（这就和SQL语句中UNION使用的时候要求上下两个语句的字段数相同是一样的意思）
    - 关系r和关系s对应位置的属性域应该是类型兼容的（同样和SQL中UNION使用时，每个对应位置字段类型兼容是一样的意思）

- ### 集合的差运算（set-defference）==>相当于SQL语句中的EXCEPT

  - #### 格式：(关系r)-(关系s)

  - 举个栗子

    - ∏ENAME,SAL(σSAL>1000(EMP)) - ∏ENAME,SAL(σCOMM>300(EMP))
    - 上面的式子表示工资大于1000但抽成不大于300的员工的姓名和工资，等价于下面的SQL语句

    

    ```sql
    SELECT ENAME, SAL
    FROM EMP
    WHERE SAL > 1000
    EXCEPT
    SELECT ENAME, SAL
    FROM EMP
    WHERE COMM > 300
    ```

  - 几点需要额外注意的

    ：

    - 此处的注意同上面的并运算的注意事项



![image-20211019173911623](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110191739670.png)

![image-20211019174556391](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110191745439.png)

![image-20211019174453035](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110191744077.png)

# 六、规范化基础

# 七、函数依赖

![image-20211020163810341](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110201638446.png)

# 八、键与约束

![image-20211020163836967](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110201638998.png)

# 九、模式分解

**步骤**

1. 找到L
2. 找到LR
3. 找到R

判断L是不是候选键，如果不是，在LR中任取一个与L构成判断

```flow

st=>start: 求候选键
cond2f=>condition: 非健属性是否部分依赖候选键
cond3f=>condition: 非健属性是否传递依赖于候选键
condBCf=>condition: 所有依赖项的左边是否全为候选键 
1nf=>end: 1NF
2nf=>end: 2NF
3nf=>end: 3NF
bcnf=>end: BCNF
st->cond2f->cond3f->condBCf
cond2f(no)->cond3f
cond2f(yes)->1nf
cond3f(no)->condBCf
cond3f(yes)->2nf
condBCf(yes)->bcnf
condBCf(n)->3nf
e=>end
```



**传递依赖判断满足一下两点**

1. B->A,A-C
2. A ≠> B

**例题**

#### 设有关系模式R（A1，A2，A3，A4，A5，A6），函数依赖集F={A1→A3，A1 A2→A4，A5 A6→A1，A3 A5→A6，A2 A5→A6}

- [函数依赖](https://www.z21.org/topic/37)

关系模式R的一个主键是（）， 从函数依赖集F可以推出关系模式R（）

问题1

A.A1A4

B.A2A5

C.A3A4

D.A4A5

问题2

A.不存在传递依赖，故R为1NF

B.不存在传递依赖，故R为2NF

C.存在传递依赖，故R为3NF

D.每个非主属性完全函数依赖于主键，故R为2NF



章节9.5.2规范化

问题1就不说了，选B。问题2中，里面的1NF和2NF时什么意思和如何区分。

根据书上的例题可以知道，第一和第二范式和传递依赖好像没有关系。第三范式才有关系。

先说2NF，方便理解。2NF就是**第二范式**。简单理解，就是在多个属性组成的主属性中，**任何一个非主属性的确定都(直接或间接的)依赖于一个完整的****候选码**(由一个属性组成或者多个属性组成的)，不依赖于一个候选码拆开后的单独的属性。比如本题，如果A2能单独确定A4，那么就表示A4是部分依赖于码，就不属于第二范式，属于第一范式1NF。本题很明显，所有的属性的确定都不单独依赖于候选码中的拆开后的码A2或者A5，比如A1的确定虽然依赖了A6，但是A6是由A2A5确定的。都依赖于A2A5，所以问题2选D。

**第一范式**就很简单，**就是每一个属性都不可再拆分成多个属性**，也就是说一个属性就存一个字段。比如一个学生字段，里面还包含学号和姓名两个小字段，这就不符合第一范式。

**第三范式**：比如本题中，因为A1的确定存在A6的传递，所以不满足第三范式。也就是说，第三范式3NF，**非主属性不能存在对于候选码的传递**。A1要依赖于A6，那么就把A1拆出去新建一个关系模式，A2A6在新关系模式中是主码，A2和A6也存在原关系模式中，但没有了传递关系。这样拆完所有的传递依赖之后，所有的关系模式都符合3NF。



再说一下这几个名词的定义，因为它们在476页和509页两个章节里有定义重复的：

本题中主属性和题干的主键相等，但定义有一点区别：

635页说，主键又叫主码，

476页说，主码是多个候选码中的一个，

476页说，候选码是一个或者一组属性它们可以确定一整行的数据。

476页说，主属性就是所有的候选码组合去重（20年或者19年的一个考题就靠这个）。但是509页说，任何一个包含在所有候选码中的单独的属性都叫主属性，不是的就叫非主属性。

所以记忆他们的顺序可以是：**最少一个或者一组属性**可以确定一行→把这一个或者一组属性放到候选码的集合(比如数组)里当做一个候选码。如果又有一个或者一组可以确定整行数据的属性，那么就再放到候选码的集合里，现在就有两个候选码了。以此类推。

候选码中→随便选一个当**主码/主键**，比如本题是A2A5。

候选码中→所有的候选码的属性组合在一起去重，得出**主属性**。

![ ](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110201640308.png)

![image-20211022142100826](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110221421904.png)

![image-20211021145659130](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211456202.png)

![image-20211021145926060](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211459118.png)

# 十、并发控制

![image-20211021164056860](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211640917.png)

<img src="https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211642869.png" alt="image-20211021164140317" style="zoom:33%;" />

![image-20211021164305172](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211643201.png)

# 十一、数据库安全

![image-20211021165236647](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211652704.png)

![image-20211021165302364](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211653391.png)

![image-20211021165338513](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211653564.png)

# 十二、分布式数据库

![image-20211021165550562](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211655618.png)

# 十三、数据仓库

![image-20211021165730547](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211657593.png)

![image-20211021165844895](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211658940.png)

![image-20211021165950310](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211659347.png)

# 十四、反规范化技术

![image-20211021170119875](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211701928.png)

# 十五、大数据

![image-20211021170156830](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211701881.png)

# 十六、SQL语言

![image-20211021170243979](https://raw.githubusercontent.com/lijinzedev/picture/main/img/202110211702022.png)
